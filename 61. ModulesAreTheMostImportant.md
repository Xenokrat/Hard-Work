# Hard Work -  Модули важнее всего-2 

## Пример: функциональный интерфейс с F-ограниченным полиморфизмом

(Для себя: F-связанный полиморфизм - это концепция, которая, используется
для ограничения использования типов в генериках таким образом, чтобы этот параметр
рекурсивно связан с собой.

Таким образом мы можем выразить идею о типе, который "завязан сам на себе",
при этом облечая выражение таких вещей, как например то что сравнение обычно подразумевается между
объектами одного типа).

В Python мы можем выразить идею с помощью классов и Протокола (из модуля typing).
Попроуем выразить идею, что "интерфейс" `Comparable` подразумевает сравнение объектов одного типа.

```python
from typing import TypeVar, Protocol, override

# Определим переменную типа-генерика, которая связана с протоколом "Comparable"
T = TypeVar('T', bound='Comparable', contravariant=True)


class Comparable(Protocol[T]):
    def compare_to(self: T, other: T) -> int: ...


# Класс, который поддерживает протокол "Сравнения"
class Record(Comparable['Record']):
    def __init__(self, name: str, length: int):
        self.name = name
        self.length = length

    def __repr__(self):
        return f'Record(length={self.length})'

    @override
    def compare_to(self, other: 'Record') -> int:
        return int(self.length > other.length)


# Пример
record1 = Record("Sales 2022", 2023)
record2 = Record("Sales 2023", 2024)

print(record1.compare_to(record2))  # Результат: -1 потому что 2023 < 2024
print(record2.compare_to(record1))  # Результат:  1 потому что 2024 > 2023
```

## Выводы

Последние 2 занятия показывают для меня важность постоянного изучения 
"продвинутых" подходов в computer science, ведь очень просто замкнуться в своем
болоте, даже не имея понятия о том, какие идеи можно выразить (пусть и с оговорками)
даже в пределах мейнстримного языка вроде `Python`.
Так, например, идея о возможности одной реализации для множества интерфейсов никак не 
могла бы прийти мне в голову, и ей не откуда появиться среди множества популярных учебных 
материалов. То же самое и с F-связным полиморфизмом (хочу отметить, что аннотирование типов в Python
достаточно мощное, чтобы выражать больниство идей из статических ООП языков как Java).
Тем не менее, использование модулей, как еще одного уровня абстракции для меня пока еще достаточно
сложная идея, в том числе потому что она практически не реализуема в популярных на текущий момент языках. 
В этом занятии пришлось использовать подход, схожий с [CRTP](https://ru.wikipedia.org/wiki/Curiously_recurring_template_pattern), который достаточно слабо выражает то, что можно описать при помощи модулей OCaml.
(Тем интереснее для меня попробовать поизучать OCaml :)).


