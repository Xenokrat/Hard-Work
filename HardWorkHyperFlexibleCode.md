# Hard Work - Как готовить сверхгибкий код

При изучении материала про "свобоные объекты", первые ассоциации, которые приходят в голову, в связи с этим понятием:

- Контроль Версий Git.
- Системы контроля миграций в БД.
- Персистентные структуры данных, которые упоминались, кажется, в "как понять в программировании все".

## Пример 1

Свободные объекты действительно напоминают чем-то контроль за созданием и управлением моделью данных в БД при помощи разного рода систем контроля за миграциями.
Рассмотрим знакомую мне систему на основе языка `Python` - `alembic`.
`Alembic` позволяет хранить все действия, производимые с моделью данных в виде файлов, которые декларативно описывают производимые действия.

Стандартная его структура:

```python
def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.execute(sa.text("create database database1;"))
    op.create_table('table1',
    sa.Column('column1', csa.types.common.String(), nullable=False),
    engines.ReplacingMergeTree(
        primary_key=("column1"),
        order_by=("column1"),
        index_granularity="8192",
    ),
    schema='database1'
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('table1', schema='database1')
    op.execute(sa.text("drop database database1;"))
    # ### end Alembic commands ###
```

Каждая "миграция" создает "сверху" над текущим состоянием БД новое изменение.
Таким образом, при пользовании данной системы, создается набор файлов, описывающих ее состояние в каждый момент времени.
Причем подразумевается, что в любой момент можно вернуться к любому из описаных ранее состояний.

Проблема, которая будем иметь место с таким подходом, почему между `alembic` и свободным объектом нельзя поставить однозначный знак "равно", это то, что определенные действия подразумевают потерю данных, с невозможностью откатить это состояние обратно (подомно тому, как в занятии указано), например:

- Имелась Таблица1.
- В Таблицу1 добавили новую колонку `column_new`.
- `column_new` заполняется данными в течении какого-то времени.
- Владельцу Таблицы1 более не требуется эта колонка, и он хочет, чтобы мы убрали ее.

В таком случае, мы просто возвращаемся к состоянию БД, когда колонка еще не существовала, однако данные в ней будут потеряны при удалении, если в `downgrade` мы просто укажем `execute "drop column 'column_new'`. 

Можно ли как-то изменить эту ситуацию? Мне видится подход, в котором будет реализовано 2 условия.

- Существует некая базовая модель данных, "raw_data_model", например, для данных парсинга мы собираем только сырые необработанные данные. Такая модель может только расширяться новыми атрибутами, но уже существующие должны никогда не изменяться.
- Миграции должны писаться таким образом, чтобы изменения, подобные описанным выше, всегда были "откатываемыми", причем в обе стороны.

Условно клиентские модели (таблицы) таким образом будут струкрурироваться на основе этой самой базовой таблицы (PostgreSQL на самом деле, как объектно-реляционная БД, предлагает много инструментов для "наследования" таблиц, жаль, что только недавно узнал об этом).

Все миграции пишутся таким образом, чтобы, например, при удалении столбца данных, в миграции (в `downgrade`) бы указан способ восстановления данных, скорее всего что-то вроде `UPDATE` запроса, который бы использовал базовую модель.

Такой подход не идеален, и требует сознательной и внимательной поддержки (миграции нужно писать правильно и осторожно, чтобы поддерживать "откат" к любому состоянию без потерь информации, тестировать такое очень сложно, ошибка приведет к потерям данных).

## Пример 2

Идеи:

- Мета-программирование
- Создание классов посредством переменных окружения / конфигурационных файлов

Из предыдущего пункта вытекает необходимость как-то динамически работать с потенциально изменяющимися во времени стукрутами модели данных в БД.

Например, мы можем парсить из JSON файла текущую конфигурацию БД и актуальные запросы

Начнем с парсинга файла:

```python
col_type = sa.Integer | sa.Boolean | sa.String | sa.Float 
Base = declarative_base()

# Маппинг типов из SQLAlchemy
column_type_mapping = {
    'Integer': sa.Integer,
    'String': sa.String,
    'Float': sa.Float,
    'Boolean': sa.Boolean
}

# Парсим настройки колонок из json файла
def parse_columns(column_details_json: str) -> dict[str, col_type]:
    try:
        column_details = json.loads(column_details_json)
        return {
            col['name']: column_type_mapping[col['type']] 
            for col in column_details
        }
    except json.JSONDecodeError:
        raise ValueError("Invalid JSON format for column details")
```

Затем, можно на "лету" собирать в рантайме декларативную ORM модель, на основе полученной информации. (помню про недостатки ORM как подхода взаимодействия с БД, но тут очень уж удобно использовать).

```python
# Прочитаем названия таблиц из окружения
table_name = os.getenv('TABLE_NAME', 'default_table')
column_details_json = os.getenv('COLUMN_DETAILS', '[{"name": "id", "type": "Integer"}]')

# Набор столбцов таблицы
columns = parse_columns(column_details_json)

# Динамически создаем класс для декларативного отображения таблицы в БД
NewTable = type(table_name, (Base,), {'__tablename__': table_name})

# также динамически создаем у класса атрибуты столбцов
for column_name, column_type in columns.items():
    setattr(NewTable, column_name, Column(column_name, column_type, primary_key=column_name == 'id'))
```

На данном этапе нам при переходе к новой конфигурации модели данных (или наоборот, возвращению к прежней), нужно будет использовать для программы, которая создает запросы к БД соответствующие наборы конфигурационных файлов.
На самом деле тут удобнее будет использовать БД для хранения этих настроечных `JSON` и там же указатель на текущую модель данных. Управлять таким подходом можно также при помощи `alembic`.

В JSON можно также хранить набор запросов, акутальный для текущей конфигураци модели данных, достаточно просто держать лист из названий этих методов.
Далее, мы:

1. Считываем набор запросов/операций из источника.
2. Сопоставляем названия запросв с методами. (т.е. код может расширяться новыми методами, но предние мы никогда не трогаем, вместо этого просто перестаем присваивать их классу-воркеру).
3. Динамически конструируем класс, присваивая ему все считанные методы.
4. Далее этот класс осуществляет работу по составлению отчетов и т.д.

Таким образом, мы можем получать код, который в любой момент времени полностью адекватен используемой модели данных.
(идея пока сырая, но скорее всего буду использовать ее в работе:)).

## Пример 3

К сожалению, раньше не сталкивался и не использовал пресистентные структуры данных.
Из пресистентных структур данных одна из самых популярных это стек.

Стек удобно использовать для задания набора операций, которые необходимо выполнить, например ежедневно.
Особенностью ежедневных заданий, которые реализуются в моей работе, является то, что часть из них может закончиться неудачей, причем таким образом, что необходимо "откатиться" на несколько операций назад.
То, на сколько операций назад нужно откатываться зависит от самой этой операции.

Таким образом, было бы очень удобно иметь версионирование для такого вида стеков.

Пример:

- При наружении работы Стека в состоянии [x] -> Переходим к версии стека 1
- При наружении работы Стека в состоянии [y] -> Переходим к версии стека 2

Такие структуры данных, к сожалению, судя по всему затрудниительно.
Есть более удобные способы для реализации такой идеи, например, просто хранить словарик, состоящий из ключа (номер операции, где произошло отклонение) - значение (стек, к которому нужно перейти).

## Выводы

Ситуация, описанная в начале данного занятия, на самом деле встечается настолько постоянно, что даже странно, что описанные методики я не встречал практически нигде ранее.
Ведь скорее необычной будет ситуация, когда конкретная разработка не обрастает набором дополнительных требований и пожеланий заказчика.
В целом также идея своего рода "версионного" контроля поступающих потоков данных, как и структур, обрабатывающих их, на сегодняшний день должна быть реализуема проще и дешевле, чем раньше. На текущий момент арендовать дополнительное место на сервере стоит не так дорого, что в лихвой может компенсировать возможность "на лету" адаптироваться к требованиям без переписывания и постоянного усложнения програмного кода.

Для себя нашел несколько идей, которые прямо очень хорошо подходят для облегчения текущим проблем с проектами, буду использовать.