# Hard Work - 3 Свойства хорошего кода

Думаю, будет правильно и интересно рассмотреть те же проекты, что и в занятии
`Hard Work - 3 Свойства хорошего кода`

- Кодовая база моего бота для `Slack`
- Программа для создания/перемещения файлов между БД и облачными хранилищами (S3, Azure и т.д.)

## Пример 1

Кодовая база моего бота для `Slack`

### 1.1 Корректная модульность проекта

```sh
├── docker-build.sh
├── docker-compose.yaml
├── Dockerfile
├── lint.sh
├── poetry.lock
├── poetry.toml
├── pyproject.toml
├── README.md
├── tests
|   ├── tests.py
└── src
    ├── app.py
    ├── service.py
    ├── config.py
    ├── data.py
    ├── main.py
    ├── my_schedule.py
```

Если попытаться оценить модульность проекта, мне кажется,
что удалось сделать модули более-менее независимыми друг от друга, 
для внесения изменений в расписание работы авто-комманд нам не нужно трогать
ничего, кроме модуля `my_schedule.py`

Проблемы я встречал, когда нам нужно добавить новую команду, формат 
которой как-то отличается от ранее встречавшихся данных.
Сильная связанность получается, за счёт того, что у большинства команд
собственный формат вывода и нет какой-то абстрагированной сущности, которая 
бы отвечала только за форматирование.

Но в целом, получаются более-менее независимые друг от друга детали.

### 1.2 Ясный замысел проекта

Вероятно, по названию модулей, не совсем понятно, какую 
цель преследует модуль service и config.

Также дополнительно стараюсь разграничивать каким-то образом
смысловые блоки внутри модуля, вроде

```py
# =============FORMATTERS================ #
...
# =============DATA UTILS================ #
```

Однако в конце концов сложно реально оценить, насколько удобно работать с проектом
другим людям, пока кто-то другой не попробует добавить что-то в проект.
В данном случае вопросы возникали тольлко относительно смыслов модулей service и config
как они соотносятся с приложеним.

### 1.3 Изменяемость в локальных пределах

Насколько просто внести новые команды в бота, или создать новое
расписание -- прямое следствие модульности проекта,
и здесь, мне кажется, удалось сделать достаточно простой для изменения код,
который при этом не потребует внесения чего-то нового в соседние модули.
Также будет достаточно просто заменить источник информации, создав новый
клиент в модуле `data`.

```py
def get_upd_data(
    query: str,
    client: Client,
    defualt_apps: set[str],
    alert_text: str,
    alert_trigger_time: int
) -> str:
    ...
```

### 1.4 Робастность/надежность

В целом способ, которым задан проект позволяет легко добавлять в бота новые команды и расписания.
Хотя никто не застрахован от создания некорректной команды, это можно легко протестировать (и цена ошибки незначительна,
т.к. все данные, получаемые из бота фактически "только чтение").
Естественно, если понадобится внедрить какое-либо более сложное поведение,
в целом имеративный подход, в котором написан проект, не слишком гибок для переиспользования существующего кода.
Однако типовые случаи изменения (которые происходят относительно часто) показали, что добавление новых команд не приводит
к значительным затруднениям даже для сторонних разработчиков.

## Пример 2

Программа для создания/перемещения файлов между БД и облачными хранилищами (S3, Azure и т.д.)

### 2.1 Корректная модульность проекта

```sh
├── azcopy
├── config.toml
├── Dockerfile
├── pyproject.toml
├── requirements.txt
└── src
    ├── database.py
    ├── data.py
    ├── __init__.py
    ├── main.py
    ├── queries
    │   ├── e_shelf.sql
    │   ├── search.sql
    │   └── banner.sql
    └── storage.py
```

Здесь ситуация чуть хуже, потому что многое в модуле `data` зависит от
`database` и/или `storage`, т.к. они являются источником/приёмником данных.
Поэтому запросы, которые описываются в data при изменении или добавлении новых
заставляют нас пересматривать код других модулей.

Хорошей идеей было бы, наверное, создать сущность вроде `DataSource`, которая
абстрагировала бы как-то объект, который может "выдать" данные по запросу, или
"принять" их.

### 1.2 Ясный замысел проекта

Также старался сделать структуру проекта максимально простой,
чтобы коллегам было понятно, что `database` отвечает за работу с БД
и `storage` именно за взаимодействие с облачным хранилищем.

Также активно пытался использовать `Enum` (не очень нравится, как они выглядят 
в Python), чтобы любые сущности в проекты были ясны непосредственно из кода.

```py
class ReportClass(Enum):
    PP = 1
    OMNI = 2


class ReportType(Enum):
    e_shelf = 1
    search = 2
    banner = 3


@dataclass
class AppConfig:
    name: str
    delivery: str
    countries: list[str]
```

### 2.3 Изменяемость в локальных пределах

Здесь, нужно признать, не удалось сделать
код достаточно изолированным, потому что в зависимости от того,
из какого источника и куда передаются данные нам придется вносить изменения
сразу в несколько модулей.

(Например, если у нас уже реализована передача из `PostgreSQL` в `S3`, то для реализации
передачи `PostgreSQL` в `Azure` не получится переиспользовать уже готовый способ из `PostreSQL`.

### 2.4 Робастность/надежность

В `Python` достаточно ограниченная возможность защититься от ошибки во время рантайма,
и, к сожалению, мы не очень застрахованы от передачи "плохих" вводных данных в конфиге.
Тут вероятно могло бы помочь использование библиотеке вроде `Pydantic`, которые берут на себя 
валидацию данных.
В целом, однако, я надеюсь, что простая структура проекта позволит не получить значительных ошибок
при добавлении данных (худший вариант -- удаление из хранилища существующих данных, которое не должно было произойти).

## Выводы

Здесь, как мне кажется, достаточно очевидна взаимосвязь
всех 4 пунктов, по которым можно оценить качество кода между собой.
Ключевым будет первый пункт, который говорит нам о том, насколько важно
сделать код максимально модульным, и наши функции/классы максимально независимыми
(точнее, зависимыми только от ближайшего контекста).

Проект с хорошо определенной модульной архитектурой позволяет другим разработчикам
сразу же прикинуть, как он работает, исходя только из структуры.
Внесение изменений в такой проект потребует изменения минимального числа модулей,
потому что это будет очевидно на уровне его дизайна, какие именно "новые детали"
программы должны относиться к каким именно её смысловым частям.

Надежность таких проектов будет следовать из ясности его устройства и независимости 
его частей (как в автомобиле очевидно что трансмиссия независима от климат-контроля)
и делать его лёгким в обслуживании.
