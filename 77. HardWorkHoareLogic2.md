# Hard Work - Логика Хоара для программистов 2

## Пример 1

Пример из класса, который запускает выполнение задач и содержит полный список задач,
выполняемые задачи и законченные задачи.

```py
class FlowGroup(BaseModel):
    group_name: str
    task_list: List[MyTask]
    _running_task_list: List[MyTask] = Field(default=[])
    _done_task_list: List[MyTask] = Field(default=[])

    ...
    def update_done_tasks(t: MyTask) -> None:
      if t not in self._running_task_list and t.is_completed():
        self._done_task_list.append(t)


# В другом месте программы
if t.is_completed():
  flow_group._done_task_list.append(t)
```

Если мы создали метод, который апдейтит выполенные классом задачи,
а потом не используем этот метод в каком-то другом месте программы,
вызывая вместо этого `append` напрямую к атрибуту класса, то это может
работать, не вызывая никаких ошибок. Однако здесь явное нарушение модульности
и в дальнейшем, если способ обновления сделанных задач измениться, мы можем 
забыть проделать обновление в других местах, кроме метода `update_done_tasks`.
(Решение, естественно, вызывать везде только метод класса).

## Пример 2

Имеем функцию-конструктор, которая производит другие функции с декоратором
`@task`. Поскольку такие функции-задачи могу выполнять самые разные действия,
у них может быть разные сигнатуры. 
В коде это разрешается передачей аргументов через `*args`.

```py
def construct_task(my_task: MyTask) -> Task:
    @task
    def _task():
        my_task.action(*my_task.args)
    return _task


class MyTask(BaseModel):
    name: str
    source: ActionSource
    action: Callable[..., None]
    args: List[Any]
    priority: int
    depends_on: List[Self]
    estimated_weight: int
    is_done: bool = Field(default=False)
```

При таком подходе, очевидно, что программа будет работать корректно
пока мы добросовестно создаём экземпляры класса `MyTask` с правильными
аргументами, однако здесь нет никаких страховок от передачи неправильных значений,
и как следствие непредсказуемого поведения (вариант улучшения, использовать `**kwargs`).

## Пример 3

Имеем метод, внутри класса, который симулирует работу
Тьюринг машины.
Этот метод парсит строковую команду и её аргумент, и выполняет некоторые действия.
Однако в самом методе никак не отражен формат принимаемой команды:

```py
  def parse_command(self) -> tuple[str, str | None]:
    command_str = self.command_str_list[self.current_command]
    parsed = command_str.split(" ", 1)
    command = parsed[0].strip().lower()
    args = parsed[1].strip() if len(parsed) > 1 else None
    # Mark
    if command[-1] == ":":
        return "mark", None
    if not hasattr(self.command_cls, command):
        raise NonValidProgram(f"\"{command}\" not implemented")
    return command, args
```

Впоследствии, единственная проверка осуществляется для того, чтобы убедиться,
что класс Команды имеет соответствующий метод.
Однако нет никакого способа убедиться, что переданный для команды аругмент
корректный или будет корректно работать в конкретном случае.

## Выводы

Писать прораммы, которые будут выполнять свою работу, при этом не являясь сколько-нибудь
устойчивыми к отклонениям и изменениям очень легко. Поэтму, наверное, так важно 
вводить модульность в код и придерживаться её: нам нужны гарантии, что изолированный
участок программы всегда отработает как предполагает его интерфейс. Иначе при любых
изменениях придется думать о каждой строке кода в проекте. Прощу думать о программе, 
как о наборе самодостаточных и надежных строительных блоков, чем о полном переплетении
частей, логика Хоара позволяет убедиться, в том что это действительно верно для блока.
 
В Python отсутствуют модификаторы доступа (если не считать таковыми переименовывание метода
(`name mangling`) через двойное подчеркивание). В связи с этим легко допускать
код, который будет нормально работать в типовых случаях, однако сломается
непредсказуемым образом при получении нестандартных данных. Думаю, что это
особенность языка, которая позволяет писать на нем быстрее, что может быть
полезно при прототипировании. И всё же часто не хватает "стабильных гарантий",
особенно при работе с внешними ресурсами. Вероятно, поэтому стали так востребованы
библиотеки вроде `Pydantic`, которые предоставляют удобный интерфейс для верификации
входных данных. При написании сколько-нибудь серьезных проектов без таких инструментов 
просто не получится обеспечить достаточную отказоустойчивость кода.
