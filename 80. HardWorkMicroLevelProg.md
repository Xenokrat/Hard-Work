# Hard Work - Правильное проектирование на микро-уровне

## Пример 1

Пример с тем, попытаться устранить неоднозначность
с тем, что все ветви if-else условия во всех участках кода
должны быть учтены.

Для этого используем `Enum` класс.
Однако в силу динамической природы типизации в `Python`
понадобиться внешний инструмент (линтер), вроде `Pyright` или `MyPy`.


```py
class ActionSource(StrEnum):
    """
    Enumeration of possible action sources for tasks.
    """
    CLICKHOUSE = "CLICKHOUSE"
    POSTGRESQL_CL = "POSTGRESQL_CL"
    EMAIL = "EMAIL"
```

Enum'ы также хорошо работают с `match-case`:

```py
match my_task.source:
    case ActionSource.CLICKHOUSE:
        ...
    case ActionSource.POSTGRESQL_CL:
        ...
    case ActionSource.EMAIL:
        ...
```

При использовании такого подхода:
- Линтер выдаёт предупреждение, если ветка не учтена в `match-case`
- Линтер выдаёт предупреждение, если мы уберём действие из `Enum`,
однако ветка его обработки останется ещё где-то в коде.

## Пример 2

Как рассматривается в материале занятия, функции с большим количеством
агрументов затруднительно вызывать иногда, т.к. требуется учесть порядок аргументов:

```py
conn = pg.connect(
    dbname,
    st.POSTGRES_CLIENT_DB_USER,
    st.POSTGRES_CLIENT_DB_PASSWORD,
    st.POSTGRES_CLIENT_DB_HOST,
    st.POSTGRES_CLIENT_DB_PORT)
```

Кроме того, в `Python` можно "заставить" функцию использовать
только keyword агрументы:

```py
def connect(/, db_name, user, password, host, port): ...
```

Можно соединить это с использованием словаря:

```py
conn_creds = {
    "db_name": db_name,
    "user": st.POSTGRES_CLIENT_DB_USER,
    "password": st.POSTGRES_CLIENT_DB_PASSWORD,
    "host": st.POSTGRES_CLIENT_DB_HOST,
    "port": st.POSTGRES_CLIENT_DB_PORT,
}
conn = pg.connect(**conn_creds)
```

В сочетании с кодом выше, мы устраняем возможность ошибки при 
установлении подключения к БД.

## Пример 3

В языке Си типичная ситуация, когда мы исползуем память в куче и указатель на неё, чтобы проводить
манипуляции с данными:

```c
struct DB_conn* conn = DB_conn_get(void);
// производим действия с соединением
free(conn);
```

Данный код является типичным, но он содержит в себе риск следующей ошибки

```c
free(conn);
dt = DB_conn_recive(conn);
```

В этом коде указатель `conn` всё еще указывает на адрес в памяти, хотя эта память уже была освобождена,
поэтому желательно также присвоить ему значением `NULL`.

Но мы можем пойти и дальше и создать макрос, который позволит нам не забыть сделать оба этих действия:

```c
#define FREE_AND_NULLIFY(ptr) do { free(ptr); (ptr) = NULL; } while(0)
FREE_AND_NULLIFY(conn);
```

Это позволит сделать код чуть более устойчивым к ошибкам из-за человеческого фактора.

## Пример 4

Недавно подумал, что если нам нужно в отдельных ситуациях (пере-)использовать объект, 
но, допустим, по немного другим правилам (например, порядку сортировки), то в `Python`
для этого отлично подойдут миксины.

```py
class WeightedMixin:
    def __lt__(self, other) -> bool: return self.weight < other.weight
    def __le__(self, other) -> bool: return self.weight <= other.weight
    def __gt__(self, other) -> bool: return self.weight > other.weight
    def __ge__(self, other) -> bool: return self.weight >= other.weight
    def __eq__(self, other) -> bool: return self.weight == other.weight
```

Допустим, теперь у нас есть операция, которая (в классе) содержит параметр `weight`,
но в обычной ситуации она сортируется например, по названию операции, а мы хотим
в определённый момент использовать её ориентируясь на "вес":

```py
class SomeOP: ...
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight
        
class SomeOPWeighted(WeightedMixin, SomeOP): ...
```

Прелесть такого подхода в том, что мы как бы определили некоторое "свойство" для объектов.
Если несколько элементов в коде используют это свойство, можно управлять им только модифицируя
поведение миксина `WeightedMixi`, не "теряя" потениально все места в коде, где такое поведение ожидается/используется.

## Выводы

Думаю, что примеры из занятия и также рассмотренные выше - это одни из примеров
того, что называют `defencive programming`. Это как раз техники программирования на
низком уровне (не на уровне дезайна проекта, а скорее непосредственно кода и небольших его частей).
Они позволяют сделать код более устойчивым как к последующим попыткам изменения 
(пример: когда внесенные изменения нужно не "забыть" распространить на несколько мест в коде, лушче
сосредоточить их в одном месте), так и к нестандартным ситуациям в рантайме (случайно получен неправильный
порядок аргументов, словарь избавляет нас от необходимости следить за этим).
При том, что программирование в целом является порой чертовски сложным занятием, встраивание своего
рода предохранителей (грубо говоря "защита от дурака") это хороший подход к тому, чтобы добавить
хотя бы немного стабильных гарантий на уровне `in small`. Небольшой ценой добиваемся бОльшей уверенности
в надежности кода, освобождаем когнитивную нагрузку на то, чтобы думать о проекте на уровне дизайна.
