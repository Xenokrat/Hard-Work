# Пример 1 (Слишком универсально)

Как мне кажется, пример попытки сделать общий интерфейс для чего-то, что будто бы имеет общие свойства:

- Возможность подключения
- Отправка "запросов"
- Загрузка и сохранение данных.

Однак при этом эти сущности слишком сильно отличаются в нюансах реализации, и поэтому приходится
придумывать на ходу как именно в контексте S3 будет выглядеть например выполнение строкового запроса.

```python
from typing import Protocol

class Storage(Protocol):
    def connect(self) -> None:
        ...
    def send_query(self, query: str) -> None:
        ...
    def load_data(self, data: str) -> None:
        ...

class S3Storage(Storage):
    def connect(self) -> None: ...
    def load_data(self, data: str) -> None: ...

    # Очевидно, что для S3 это не совсем подходит
    def send_query(self, query: str) -> None: ...
```

Также S3 как бы не очень позволяет просто прочитать любой файл на месте, а для базы данных это вполне естественно.
Поэтому более логично держать эти сущности отдельно.
При необходимости я думаю, можно придумать какой-то адаптер, который будет приводить S3 к чему-то похожему на
запросы в базу данных, однако общий интерфейс это явно плохая абстракция.

# Пример 2 (Слишком универсально)

Общий интерфейс для транзакционной базы данных и НЕ-транзакционной
В некотором контексте вероятно нормально объединять OLAP и OLTP базы данных в один интерфейс,
особенно когда речь идет о read-only системах.

```python
from abc import ABC, abstractmethod

class Database(ABC):
    @abstractmethod
    def exec_raw_query(self, query: str) -> None:
        ...

    @abstractmethod
    def exec_transaction(self, query: str) -> None:
        ...

class PostgresDatabase(Database):
    def exec_raw_query(self, query: str) -> None: ...
    def exec_transaction(self, query: str) -> None: ...
        
class ClickhouseDatabase(Database):
    def exec_raw_query(self, query: str) -> None: ...
    def exec_transaction(self, query: str) -> None: ...
```

Ключевой вопрос: что должен делать ClickhouseDatabase при вызове `exec_transaction`? При имплементации
этого метода в Clickhouse нет понятия транзакции, поэтому этот метод должен либо не делать ничего,
либо вызывать исключение. В крайнем случае можно реализовать запрос-откат, но это очень сомнительная
идея.

Тут важную роль играет как раз принцип "не создавай сюрпризов" для программистов, которые будут использовать
библиотеку.
Программист, использующий интерфейс `Database`, не должен думать о том, что в Clickhouse транзакции нет,
хотя метод `exec_transaction` подсказывает, что будто бы есть.

Разумный подход: разделить интерфейс на два:

```python
from abc import ABC, abstractmethod

class TransactionalDatabase(ABC):
    @abstractmethod
    def exec_transaction(self, query: str) -> None:
        ...
    @abstractmethod
    def exec_raw_query(self, query: str) -> None:
        ...

class NonTransactionalDatabase(ABC):
    @abstractmethod
    def exec_raw_query(self, query: str) -> None:
        ...

```

# Пример 3 (Недостаточно универсально)

Реализация slack-bota через веб-сокет и через эндпоинт на бэкэнде.

Библиотека для создания slack-ботов - `slack-bolt` предоставляет возможность создания ботов как в 
условно "классическом" режиме с отправкой сообщений на бэкенд (эндпоинт), так и альтернативный режим
через веб-сокеты. Второй вариант на порядок удобнее, так как не требует собственно выделенного бэкенда
с эндпоинтом - достаточно просто развернуть приложение на веб-сервере.

```python
from slack_bolt.adapter.socket_mode import SocketModeHandler

from app import app
from config import SLACK_APP_TOKEN
from my_schedule import run_schedule


# ... Детали реализации ...

def main() -> None:
    run_schedule()
    # Start the background thread
    stop_run_continuously = run_continuously()

    # Do some other things...
    socket_handler = SocketModeHandler(app, SLACK_APP_TOKEN)
    socket_handler.start()

    # Stop the background thread
    stop_run_continuously.set()
```

Вариант с сокетом был выбрак как более простой, однако нам в какой-то момент может понадобиться подменить
реализацию на что-то другое. Например, нам нужно будет поддерживать несколько ботов, которые будут
использовать один и тот же бэкенд. В этом случае было бы удобно иметь возможность подмены реализации.

```python
from slack_bolt.adapter.socket_mode import SocketModeHandler


class SlackAppFactory:
    @staticmethod
    def create_app(self) -> SlackApp:
        ...

class SlackApp(ABC):
    @abstractmethod
    def start(self) -> None:
        ...

class SocketModeSlackApp(SlackApp):
    def start(self) -> None:
        ...

# Например для Flask
class FlaskSlackApp(SlackApp):
    def start(self) -> None:
        ...

```

# Пример 4 (Недостаточно универсально)

Запуск ETL тасок в асинхронном режиме и синхронном.

Ещё один пример вероятно недостаточной универсальности - допустим мы имеем приложение, которое 
запускает ETL таски. По умолчанию оно реализует асинхронный режим, используя конфиг вроде:

```yaml
stages:
  - stage: "Name"
    tasks:
      - task1
      - task2
```

В этом случае `task1` и `task2` будут запускаться в асинхронном режиме. 
Однако возможна ситуация, когда нам нужно запустить эти таски последовательно (т.е. синхронно) - например
для тестирования, или когда таски зависят друг от друга и этого нельзя избежать.
Было бы идеально в таком случае предоставить пользователю возможность подменить реализацию исполнения задач.

Попробуем предоставить интерфейс для решения этой задачи:

```python
from abc import ABC, abstractmethod

class Task(ABC):
    @abstractmethod
    def run(self) -> None:
        ... 

class AsyncTask(Task):
    def run(self) -> None:
        """
        Запускает задачи в асинхронном режиме, используя event-loop.
        """
        ...

class SyncTask(Task):
    def run(self) -> None:
        """
        Запускает задачи в синхронном режиме.
        Задачи выполняются последовательно как они расположены в конфиге.
        """
        ...
```

## Выводы

Что я понял из своего опыта и последних нескольких занятий Hard Work - это то, что
с одной стороны, интерфейсы и абстрактные классы это хороший инструмент для создания
гибких и расширяемых систем. Но с другой стороны возникает большой соблазн создания слишком
универсальных решений.

Недаром в противовес всем этим идеям, связанным с раширяемостью кода были также выдвинуты принципы
YAGNI и KISS, которые пытаются предостеречь нас от попытки решить все проблемы заранее - даже такие 
проблемы, которые ещё не существуют (например попытка предоставить возможность замены для абсолютно
любых компонентов системы).

Но главный принцип (как это и было описано в занятии) - это то, что нужно стремиться создавать
небольшие и простые компоненты, каждый из которых решает конкретную четко определенную задачу.

Такие компоненты легко повторно использовать, легко тестировать и легко подменять.
Их также при необходимости будет легче переписать (или провести рефакторинг). Лучше попросту иметь
богатый набор решений, чем один единственный "мультитул" для всех задач.


