# Hard Work -  E2E ваше всё 2

## Компонеты для тестирования

### 1. Framework для UI-тестов

Может быть реализован на основе Selenium, Cypress, Playwright, в моём случае использовал бы `Cypress` просто потому что использовал его раньше.
Фреймворк нужен нам для автоматизирования следующих действий:

- Запускают браузер.
- Переходят на нужную страницу.
- Выполняют необходимую подготовку данных/состояний.
- Делают скриншот.

### 2. Способ сравнения скриншотов, сделанных фреймворком

Сравнивает полученные скриншоты с эталонными (базовыми).

Для попиксельного сравнения нашёл библиотеку [pixelmatch](https://github.com/mapbox/pixelmatch)
Но оказывается для чего-то подобного уже существуют решения с AI, например - [Applitools Eyes](https://applitools.com/platform/eyes/)
Есть еще [Percy](https://percy.io/), вроде как тоже может "по-умному" находить разницу между скриншотами.

Последний имеет ограниченный бесплатный доступ и возможность интеграции с `Cypress`.
К сожалению у меня не получилось связать его с своим "дипломным" проектом Автопарка на Django, всё-таки все эти решения
очень быстро становятся "платными".

Но в демо проекте хорошо видно, как он определяет разницу между скриншотами:
![percy-demo](percy-demo.png)


### 3. Хранение скриншотов

Хранилище эталонных (базовых) скриншотов
Сами эталонные изображения хранятся в репозитории (например, Git) или в каком-то внешнем хранилище (S3, Azure?).
Какое-то версионирование самих файлов скринов тоже не помещает для обновления "базовых скриншотов".

### 4. CI/CD пайплайн

CI/CD-система
    Тесты по сравнению скриншотов обычно запускаются автоматически при коммитах или pull-request’ах.
    При появлении расхождений создается отчет и (опционально) блокируется слияние PR до одобрения новых эталонов или исправления регрессий.

## Примерная схема тестирования

### 1. Подготовка окружения

В CI/CD или на локальной машине поднимается “чистое” окружение в Docker-контейнере.
Запускается тестовый сервер.

### 2. Запуск браузера

Используются драйверы для реального браузера (Chrome, Firefox).

### 3. Переход на нужную страницу и выполнение сценария

Тестовый код (через `Cypress`) кликает по элементам, вводит данные, переходит на нужные страницы и т.д.
Ожидается нужное состояние страницы (по загрузке элемента, таймингам анимаций и т.п.).

### 4. Создание скриншотов

Снимается скриншот всей страницы или конкретных элементов (в зависимости от задач теста).
Фреймворк сохраняет скриншот в папку.

### 5. Сравнение скриншотов с эталоном

Программа сравнения берёт полученный скриншот и сопоставляет с базовым.
Если различия в пределах допустимого порога (pixel-by-pixel сравнение с некоторым пороговым значением):

Формируется «diff»-изображение, на котором обычно подсвечиваются отличающиеся пиксели/области.
Создается отчет (HTML-репорт, комментарий в CI-системе, и т.д.) с информацией о расхождениях.

### 6. Обновление эталонных скриншотов (при необходимости)

Если изменения в UI — ожидаемые, то принимается решение обновить базовые скриншоты новыми.
Новые изображения добавляются в хранилище.


## Итоговая архитектура

Упрощённо архитектура может выглядеть так:

### Git-репозиторий

Хранит:

- Код приложения и тесты.
- Папку /screenshots/base — эталонные скриншоты.
- Папку /screenshots/diff — результаты сравнения (создаются при тестах).

## CI-сервер:

Получает обновления из репозитория по событию Pull Request / Push.

Поднимает Docker-контейнер или VM, внутри которой:

- Устанавливает/запускает нужные браузеры.
- Устанавливает тестовый фреймворк (`Cypress`).
- Запускает приложение.
- Запускает тесты.
- После выполнения тестов генерирует отчет о сравнении скриншотов.

Если обнаружены расхождения, процесс помечается как *failed*.
Если изменений нет или они ниже некоторого порога - *success*.

## Отчет о тестировании:

Сохраняется в CI. Может автоматически создавать Pull Request, прикрепляя ссылки/изображения с диффами.

## Процесс принятия изменений:

Если изменения в UI ожидаемые:
Обновляются эталонные скриншоты (добавляются в репозиторий/хранилище).
При следующем прогоне тестов всё должно пройти без расхождений.

## Выводы

Похоже, что такая идея автоматизированного тестирования UI по-видимому получила большое развитие с
появлением ИИ - все эти фреймворки вроде `Applitools` или `Percy` как раз берут на себя почти всю работу, и при этом
позволяют анализировать изменения одновременно "по умному" при помощи компьютерного зрения и объективно.
Автоматически замечать непреднамеренные визуальные изменения и страховаться от регрессий в верстке и дизайне - это вообще
дорогого стоит. В конеце концов человеку легко пропустить изменения в визуале, даже если ему предложить для сравнения "было/стало".
До этого занятия я в целом даже не подозревал, что достичь автоматизации тестирования визуальной состовляющей приложений можно
таким вот способом.
