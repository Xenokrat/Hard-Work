# Hard Work - Логика Хоара для программистов 4

## Зависимость от более строгого результата, чем гарантируется спецификацией

### Пример 1

Здесь возможно пример вынужденой зависимости, потому что при написании парсеров
интернет приложений.

Например, в следующем коде предполагается, что "главное" изображение со страницы
с товарами всегда будет идти на первом месте, но строго говоря это не гарантированно
"спецификацией" плоащки, которая парсится:

```py
main_image = None
pictures = []
for count, image in enumerate(product['image_links']['normal'], 1):
    picture = image if len(image) <= 512 else None
    pictures.append({'image_url': picture,
                     'image_number': count})
    if count == 1:
        main_image = picture
```

Это, вероятно, может привести к трудно обнаруживаемой ошибке, когда долгое время "главным" будет записываться 
неправильное изображение.

### Пример 2

Следующий код копирует файл из облачного хранилища s3 в Azure.
Мы исходим из предположения, что копируемый файл `file_path`
не существует в Azure до копирования.
Спецификацией однако, не гарантировано, что со стороны Azure по какой-то причине этот файл не будет существовать.

```py
if DRY_RUN:
    logger.warning("Skipping actual COPY to client's Azure")
if not DRY_RUN:
    azure_sdk = get_azure_sdk(file_path)
    logger.debug(f"Azure str: {azure_sdk}")
    try:
        client_execute(client, check_query, {})
        execute_command(s3_full_path, azure_sdk)
        logger.debug(f"Executed command for: {app_config.name}")
    except ServerException:
        logger.warning(f"Got empty file on {file_path}, skipping copy")
```

В таком случае этот файл будет перезаписан, и как следствие утерян при выполнении данного кода.

## Зависимость от возможности использовать более мягкие реализации, чем гарантирует спецификация

### Пример 3

Спецификациая SQL запроса требует, чтобы подставляемый параметр `app` гарантированно был корректным названием площадки.

В реализации кода ниже

```py
apps = config.get("apps", [])
client_execute(client, insert_s3_query, {
    "date_start": date_start,
    "date_end": date_end,
    "apps": apps,
})
```

В apps возможно передать какие угодно значения, они не только не гарантированы быть правильными названиями, но также
могут быть например List[int] вместо List[str]

Гораздо худшим пример станет, если:

```sql
SELECT *
FROM table
WHERE app NOT IN %(apps)s
```

В этом случае нужные площадки не отфильтрованы, и вместо пустого ответа будут включены ВСЕ площадки.

### Пример 4

Допустим, есть часть кода, которая выводит количество свободных ресурсов на 3 нодах:

```py
res = {}
nodes = [Resource.NODE1, Resource.NODE2, Resource.NODE3]
for node, (host_t, value_t), (host_c, value_c) in itertools.product(
    nodes,
    total_resourses,
    current_resourses
):
    if node.value == host_t == host_c:
        res[node] = int(value_t * MAX_NODE_RESOURCES_USAGE - value_c)
return res
```

Если подумать, то если ноды существуют постоянно и спецификация, следовательно, требует, чтобы 
ответ всегда был получен в полном объеме, то код выше этого не гаратнирует, можно получить, 
например, пустой результат.

В идеале, можнжо добавить этому коду немного "гарантий":

```py
assert res, "empty result"
assert all([(key in nodes) for key in res.keys()])
```

## Принцип робастности/надёжности Постела

У нас в БД есть столбец, который хранит данные в JSON формате.
От этого столбца зависит работа кода, который участвует в формировании данных.
Этот столбец очень часто подвергается изменениям, о которых часто коллеги не уведомляются.
Но обычно это "прощается" как раз потому, что обычно изменения связаны с добавлением новых полей,
а не удалением/изменением старых. 
Как правило данные достаются оттуда просто при помощи `JSONExtract`, поэтому новые поля ничего не "ломают".
Но потенциально это созаёт ситуацию, когда разрушающее измненеие всё же будет внедрено.
Решение здесь это только установить процесс внесения изменений в JSON поле, при котором все заинтересованные
будут уведомлены.

## Общение с коллегами на третьем логическом уровне

Возникают сложности с этим: большинство коллег рассуждают 
или на буквальном уровне ТЗ, (т.е. требуется от заказчика) или уже на уровне конкретного кода.
Когда речь заходит об каком-то более абстрактном уровне, хотя бы даже тех же модулей
(обычно о модулях думаю как об организации кода в нескольких файлах).
Некоторые более опытные коллеги, которые составляют документацию на уровне модуля,
могут и сильно рассуждать на этом уровне, хотя это происходит обычно как раз уже после написании кода,
при составлении этой документации. В целом согласны, что начинать с 3 уровня правильно, но на практике для этого
обычно не хватает дисциплины/времени.

## Выводы

Это занятие даёт понимание, как важно соответствие кода какому-то абстрактному пониманию проекта, т.е. его спецификации,
причём здесь не нужно путать её с "сырыми" требованиями конечного потребителя. Вместо этого имеет место то самое
мысшление на 3-м уровне, когда мы огранизуем все элементы согласно потоку входных значений/требований и требуемому результату
на выходе. Здесь требуется задавать множество вопросов, которые, вероятно не отражаются в спецификации, общаться с коллегами
и держать в курсе потребителя.
Все элементы проекта должны быть как-то соотнесены с этой спецификацией, и следует учесть, когда возможны не соответствия (например, в одном
из двух типов ошибок, что мы рассмотрели выше), и правильно реагировать на это (возможно, например, более "слабая" реализация по отношению
к спецификации это нормально, если код будет работать в таких-то условиях).
Ну а для себя в очередной раз убедился, как полезно заранее прописывать дизайн модуля перед его созданием.
