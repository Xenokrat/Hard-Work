# Hard Work - Страшное слово в ваших спецификациях 

## Пример 1

У нас есть абстракция для единицы выполнения некоторых действий в БД, условной стейдж.
В определенный момент времени оказалось, что в ходе выполнения стейджа, нужно не только проводить операции в одной конкретной БД,
но иногда в разных инстансах БД одного типа, затем в полностью другой БД, затем оказалось, что дополнительно в "стейдже" может дополнительно происходить почти любое 
действие, например отправка письма, или сообщения в телеграм.

В данном случае, попытались "избавиться от необходимости" иметь дело со всем следующим образом:
Отдельная иерархия классов для действий только с БД, т.к. они близки по операциям, кроме того, эти операции составляют 95% всех действий.
Другие действия, такие как оправка письма, вынесены полностью отдельно.
Выполнить вместе эти действия возможно при помощи паттерна "Посетитель", который позволяет при выполнении действий с бд заодно "обойти" все дополнительные задачи.

## Пример 2

Схожая ситуация происходит при использовании Slack-бота, задача которого предоставлять менеджерам аналитическую информацию из БД.
Возникает схожий запрос, заключающийся в предоставлении через бота других возможностей, например также отправки отчета с сервера на почту и т.к.
В данном случае, эту проблему мы решили, полностью отделив аналитического бота от всех остальных сервисов, так как все запросы в БД имеют очень близкую
структуру и реализуются схожим образом.
Все остальные сервисы с использованием бота должны быть проанализированы и вынесены отдельно (предпочтительно, в отдельного бота).
(т.е. фактически мы ограничили на уровне спецификации входные требования).

## Пример 3

Имеется программа-парсер для сбора информации с сайта приложений доставок еды.
Структура сайта приложений доставок может в значительной степени отличаться, например, от мобильного приложения.
Кроме того, различные приложения также могут отличаться в достаточно значительной степени.
Однако, естественно, требования спецификации подразумевают, что мы должны собирать "всё" со страницы товара.
В данном случае, была изменена струкрута программы.
Изначально, собирается полная информация со всех страниц товаров.
Затем эта полная "сырая" информация записывается в БД "как есть".
Далее подключается вторая программа, которую мы называем "пост-парсер".
Этот парсер создан уже не для того, чтобы собирать информацию из веб-приложения, но для того, чтобы парсить этот сырой формат данных 
(который представляет собой JSON-структуру).
Таким образом мы разделили ответственность за сбор и интерпретацию информации и можем отдельно построить иерархию пост-парсеров, подстаивая классы-потомки
под специфичные особенности каждого приложения.

## Пример 4

Как уже было отмечено в примере 3, в нашей системе для парсинга информации по приложениям доставок есть 2 основных элемента, это парсер и постпарсер.
И мы уже разобрались, как возможно иметь дело с поступающей информацией на уровне парсера.
Постпарсеру также, потенциально, приходится иметь дело с "любой" поступающей из внешнего мира информацией.
Единственный способ, который мы нашли, для того, чтобы не получать постоянные сбои в работе программы - это

- Выделить общую струкруту, которая характерна для всех приложений
- Выделить элементы, характерные конкретно для этого приложения
- Все остальное нужно "отлавливать" и изолировать от остальной информации (для того, чтобы, возможно, впоследнствии проанализировать и когда-нибудь вынести 
эту информацию в один из 2-х предыдущим пунктов. Также возможно, что эта информация так навсегда и останется "мусором").

## Пример 5

Прогамма для объединения отчетов в один, использующая питоновскую библиотеку "Pandas".
"Pandas" при загрузке отчетов, превращает информацию в столбцах в соответствующие Python-объекты: float, int, списки и кортежи, и так далее 
(плюс дополнительные типы, которые использует NumPy).
Фактически, по спецификации работы программы, подрузумевается, что мы можем использовать любые столбцы для `join`'a отчетов, однако на практике,
невозможно использовать для этого "изменяемый" тип данных.
Возможно было бы временно преобразовывать, например, set -> frozenset и лист в кортеж и т.д. 
Однако в Python потенциально вполне могут встречаться пользовательские мутабельные типы данных, поэтому нужен унивесальный механизм, чтобы
иметь дело со "всеми" типами. Вероятно, он должен выглядеть следущим образом:

- try: сделать join по указанным полям
- except: при ошибке сделать join по строковому представлению типа данных в указанных полях

## Выводы

В реальном мире очень часто нам приходится иметь дело с необрпеделенностью, котрую крайне сложно каким-то образом старндартизировать или предсказывать.
Примером такого может быть поведение пользователя, информация с внешних API, данные web-scaper'ов.
Наиболее успешным выбором в таком случае будет скорее всего попытаться каким-то образом изолировать "несовершенный" внешний мир, чтобы затем
можно было уже безопасно работать с полученными данными, не боясь поломок ПО. 
Однако второй сценарий, который приводит к необходимости иметь дело со "всем", происходит уже изнутри, и его причиной является несовершенный дизайн
и/или постоянно меняющиеся требования. В таком случае может быть целесообразно перепроектировать систему, чтобы разграничить это "все" на более конретные сущности, 
 с которыми удобно работать, однако это всегда будет вопросом отношения затраченных на перепроектирование усилий против возможности просто ограничить "все", хотя бы на уровне спецификации.
