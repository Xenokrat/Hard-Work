# Hard Work - Разбираемся с DRY

## Пример 1

Кода-то ещё давно, когда у меня была потребность замерять скорость работы
с какими-то внешними сервисами в `Python` мне пришла в голову идея, что
писать каждый раз:

```python
start_time = time.time()
result = await some_function()
end_time = time.time()
elapsed_time = end_time - start_time
```

как-то не очень хорошо (если что я осознаю, что это плохой способ для точных
бенчмарков, однако для оценки длительный процессов работает). 

Поэтому, в какой-то момент был придуман декоратор для функций, который позволяет
измерить и залогировать время выполнения каждой из них:

```python
class TimingLogger(logging.Logger):
    def __init__(self, name, level=logging.NOTSET) -> None:
        super().__init__(name, level)

        formatter = TimingFormatter("%(asctime)s %(levelname)s %(name)s %(message)s")
        handler = logging.StreamHandler()
        handler.setFormatter(formatter)
        self.addHandler(handler)

    def timing_decorator(self, message: str, log_level: str = "info") -> Any:
        def _timing_decorator(func: Callable) -> Any:
            @wraps(func)
            async def wrapper(*args, **kwargs) -> Any:
                start_time = time.time()
                result = await func(*args, **kwargs)
                end_time = time.time()
                elapsed_time = end_time - start_time
                self.__getattribute__(log_level)(
                    f"{message} - time spent {elapsed_time:.2f}."
                )
                return result

            return wrapper

        return _timing_decorator
```

Декоратор в целом работает хорошо, однако даже у него есть ряд проблем:

- Если мы хотим измерить что-то точечно внутри функции, то нужно либо выносить это
в отдельную микро-функцию, или отказаться от этой идеи.
- Для функций, которые уже используют декораторы, нужно подходить к использованию
с осторожностью, так как измерения могут быть обманчивыми и зависеть от порядка
декораторов (не всегда можно сделать его внешним).
- Если хочется залогировать дополнительную информацию, то декоратор не подходит.

В любом случае, не думаю что это именно плохая абстракция, однако она очевидно не может
заменить прямолинейное измерение времени в любой ситуации.

Поэтому я считаю, что нет ничего плохого в конструкции:

```python
start_time = time.time()
result = await some_function()
end_time = time.time()
elapsed_time = end_time - start_time
```

несмотря на то, что она может дублироваться многократно в коде.

## Пример 2

Написать про то, как 
У меня была ситуация, когда под одного клиент нужно было заполнять
таблицы с данными с схожей структурой (туда входили магазин - продукты - дата
и т.д. - такие данные легко обобщить).

Из-за похожей структуры я в какой-то момент заметил дублирование, и обобщил
заполнение этих таблицы в единственной функции, которой просто нужно передать
параметр названия таблицы `table`.

```python
def main_stats(
    table: str,
    date_start: Optional[dt] = None,
    date_end: Optional[dt] = None,
    app_list: Optional[List[str]] = None,
) -> None:
```

Далее, мы просто определям вещи, специфичные для конкретной таблицы в `if-else` конструкции, и далее работаем одинаково.

```python
if table == "type1":
    conf_template = "eshelf_file_path_template"
    MONITORING_QUERY = get_query("src/queries/monitoring.sql")
elif table == "type2":
    conf_template = "type2_file_path_template"
    MONITORING_QUERY = get_query("src/queries/monitoring_type2.sql")
elif table == "type3":
    conf_template = "type3_file_path_template"
    MONITORING_QUERY = get_query("src/queries/monitoring_type3.sql")
else:
    raise ValueError(
       f"Arg: table should be in ['type1', 'type2', 'type3'], "
       f"got {table}"
    )
```

Всё это работало хорошо, но к сожалению, быстро стали появляться новые требования,
специфичные для каждой из таблиц. Например, для одной (и только одной) из них требовалось переименовывать
некоторые названия в колонках специфичным образом:

```python
PP_APP_NAME_OVERRIDE = {
    "type1": "renamed1",
    "type2": "renamed2",
}
```

Поэтому вся эта универсальность каждый раз трещала по швам, нужно было прописывать
исключения на каждом шагу. Поэтому я просто сдался, и сделал отделные функции для
каждой из типов таблиц, которые содержат некоторое количество дублирующегося кода.

Не думаю что у таблицы можно выделить общее свойство как "переименовываемость одних
значений столбцов в другие". Такие требования, обычно очень специфичны и уникальный под каждый случай, и как-то
абстрагировать их сложно. Поэтому мне кажется, что лучше допустить дублирование, чем
надстраивать общую конструкцию (например в классе), которая позволила бы произвольно 
модицифировать значения в колонках.

## Пример 3

Мне кажется, хороший пример "протекающей" абстракции:

Для вывода сообщений (алертов о негативных событиях
в сервисах и БД) в боте, которого мы используем, часто бывает потребность
выводить таблицу с результатами (в `Markdown` формате).

Таблицу на первый взгляд не так уж сложно абстрагировать - в ней есть:

- Название (или другой информационный текст перед таблицей)
- Заголовки столбцов
- Разделитель
- Непосредственно строки и данные в них.

Например, что-то вроде следующего кода:

```python
# Date
table += f"Date: {result[0][0]}\n"
    result = [x[1:] for x in result]

# Header
for f in fields:
	table += "|" + f[0].center(f[1])
    table += "|\n"

# Divider
for f in fields:
	table += "|" + "-" * f[1]
	table += "|\n"

# Data
for r in data:
	table += _format_row(r, fields)
	return table
```

Этот подход работает хорошо, если мы ожидаем данные:
- в уже готовом виде
- не слишком большой длины
- без необходимости проводить какие-то другие манипуляции с текстом.

К примеру, нам хочется не просто представить значения в таблице, но добавить
progress-bar в ячейки столбцов:

```python
for i in data:
	percent_val = (str(round(i[3], 1)) + "%").ljust(6, " ")
	progess_bar = ("=" * (int(i[3]) // 10)).ljust(10, " ")
	percent_record = (" " + percent_val + " [" + progess_bar + "]").ljust(20, " ")
```

Наша абстракция таблице выше уже не очень хорошо для этого подходит, разве что
ПЕРЕД формированием таблицы мы прогоним данные через какую-то отдельную функцию,
которая преобразует текст в прогресс-бар.

Но я заметил, что ГОРАЗДО проще просто иметь РАЗНЫЕ функции под каждый случай формирования таблиц, потому что в них постоянно нужно (или напротив, не нужно) производить уникальные для каждого типа сообщения в мессенджер манипуляции с текстом. В случае разных
функци формирования таблиц, пусть даже с дублированием кода, эти особенности легко выразить, не создавая дополнительных функций-обработчиков текста. Вся логика построение таблицы
прямолинейна и может быть прочитана в одном месте, вместо дополнительных перескакиваний
в программе.

## Выводы

Абстракции призываны сделать так, чтобы со "многими вещами можно было обращаться, как с одной" - 
этому же следует принцип DRY - дедупликация кода позволяет нам "консолидировать" как управление потоком
выполнения программы, так и внесением изменений из единственного "де-дублированного" места в программе.
Поэтому программисты (как и я в определённый моммент) часто становятся одержимы этой идеей - никогда не повторять код,
всегда искать как обобщить любые повторения, найти абстракцию, которая позволит объединить большое количество кода.
Но слепо следовать такому поведению так же плохо, как и не пытаться абстрагировать вообще ничего. Абстракция ради
абстракции будет "подтекать" (т.е. её внутренние детали имплементации выйдут наружу и будут мешать корректной работе).
В преждевременно "обобщенном" коде появятся существенные различия, к которыми абстракция была не готова.
DRY - это без сомнения хороший принцип, но отнюдь не догма, и для устранения повторений желательны:

- Покрытый тестами код.
- Естественная потребность в "управлении-в-одно-месте".
- Уверенность в том что "объединяемые" части действительно схожи и будут оставаться такими во времени.

Во 2 примерах выше, кстати, сама по себе плохой, однако частные случаи вскрыли
недостатки, которые могли бы быть учтены заранее, и мы могли бы не тратить время
пытаясь подогнать решение под все варианты.
