# Hard Work - Что такое абстракция: основное

## Пример 1

Уже приводил где-то раньше этот пример из работы.
Для ежедневных действий с использованием данных из БД, таких как составление агрегированных данных, группированных по дню, или отчетов, или передача этих отчетов в клиентские БД, создали небольшой фреймворк, который позволял бы проводить все эти действия автматизированно.

Для такого фреймворка выводим следующие понятия:

- `Программа` - это будет полный список всех действий, которые необходимо выполнить, однако некоторые действия удобно сгруппировать и выполнять одновременно, поэтому вводим также `стадия`.
- `Стадия` - это список `задач`, которые логически объединены и могут выполняться параллельно, например заполнение нескольких таблиц в клиентской БД при условии, что данные преварительно уже готовы для этого.
- `Задача` - уже конкретнное действие, вроде составления и отправки отчета. Но так как это 2 действия, их также удобно разделить на `подзадачи`.
- `Подзадача` - самое элементарное действие, вроде запроса к БД или оправки письма.

Абстрагируя в таком виде, можно представить список ежедневных операций в виде JSON или yaml файла, которые будут состоять из списка стадий, в которых задачи будут выполняться параллельно друг с другом. При этом каждую задачу можно предсавить как последовательность элементарнных действий, и на более высоком уровне уже не задумываться, о деталях выполнения каждой задачи.

## Пример 2

Имеем схожий проект с проектом из примера 1, в котором:

- имеется набор классов, отвечающий за действия, производимые с данными каждого клиента.
- в каждом классе есть набор методов, которые производят те или иные действия с клиентскими данными. Важная особенность здесь то, что нет единственной и неизменяемой последовательности для выполнения этих методов, т.е. нужна некоторая гибкость в том, какие методы мы выполняем и в какой последовательности. Например, требованием может быть пересоздание матетиализованного вью в БД клиента, формирование определенного отчета, затем отправка письма с уведомлением. В другом случае уведомление может быть не нужно, и тип отчета может быть другим.
- Методы этих классов слишком разные, чтобы их можно было организовать в какую-либо иерархию классов.
- тут как раз приходит на помощь паттерн "Посетитель". Можем расширить все эти существующие классы методом `accept`. Здесь удобно использовать класс питоновский `Protocol`, который как бы позволяет симулировать интерфес.

```python
class VisitorCompatible:
    def accept(self) -> None: ...
```

Теперь можно расширить клиентские классы, унаследовав их от `VisitorCompatible`.

```python
class Client1(VisitorCompatible):
    def accept(self, visitor: Visitor) -> None:
        visitor.visit_client1() 
```

- далее нам нужно создать иерархию "Посетителей". Этих посетителей пользователь выбирает в засисимости от какого-либо набора действий, которые ему нужно выполнить.

```python
class Visitor(ABC):
    @abstractmethod
    def visit_client1(self) -> None: pass

    @abstractmethod
    def visit_client2(self) -> None: pass
    ...
```

Такой способ абстракции взаимодействия между набором действий, связанных с клиентом позволяет во первых, не изменять уже существующие методы классов, а во вторых, создавать новые классы "Посетителей" которые могут как угодно переиспользовать уже существующие методы, в любой нужной последовательности.

## Пример 3

Пример из задачи, которую я как раз выполняю, поэтому тема абстракций очень актуальна :).

Есть список продуктов (чипсы, соки и т.д.) от сторонней компании, которая экспертно занимается отслеживанием такого рода продукции, и у них есть уникальный идентификатор, которые наш клиент хочет сопоставить с данными о продуктах, которые мы ему отгружаем.

Таким образом, задача следующая -- найти соответствие продуктам в нашей БД (которые берутся из парсинга приложений доставок) однозначное соответствие в списке этой компании и сопоставить идентификатор.

Тут естественно множество проблем, начиная с того, что предоставленная нам информация содержит записи только на латинице, причем иногда это перевод, иногда транслитерация. То, как приложения доставок отдают нам названия также далеко от идеального :).

Абстракция, до которо я додумался (по крайней мере на текущий момент):

- Существует 2 параметра, которые относительно точно определяются из названия продукта - это его бренд и характеристика упаковки (вес, объем, шт. в коробке и т.д.).
- Над обоими списками проводим аналогичную операцию: извлекаем бренд из названия, извлекаем численную характеристику.
- Получаем 2 сущности, с 2 полями каждая, делаем своего рода `JOIN` по этим 2 полям.
- Все что мы НЕ извлекли на предыдущих шагах - область описания товара, его вкус, цвет и т.д. самая сложная часть для сопоставления, (назовем ее `Other`) однако мы сильно сократили число вариантов на предыдущих шагах.
- Осталось только сопоставить по этой части `Other` товары друг с другом. Здесь, т.к. общий подход абстрагирован, можно "атаковать" проблему с разных подходов, и смотреть на результат: можно использовать алгоритм Ахо-Корасика, лингвистическое расстояниие, отправить по API в ChatGPT в конце концов :). Можно задуматься о численной характеристике (confidence level) и сохранять, например, топ-3 результатов, что будет возможно уже проще отсматривать живому человеку.
- Часть, которая будет уже на совести пользователя -- выбрать какая метрика реально дает наилучший результат.

## Пример 4

Абстракция, которая используется для реализации графического приложения, отображающего ленту машины Тьюринга.
Для отображения проще всего использовать список.

Такой список будет фактически представлять собой ленту. Элемент, отвечающий за отображение графики будет считывать значения из списка и отрисовывать ленту в зависимости от состояния списка.

В `Python` список очень хорошо подходит для реализации задачи, так как он:

1. Поддерживает значения любых типов
2. Является динамическим.

Также будем держать в памяти индекс текущей ячейки, который по сути является курсором (указатель на текущую ячейку в Машине Тьюринга).

Краний левый элемент на ленте всегда считается нулевым, т.е. соответствует индексу 0.
Лента потенциально бесконечная, однако список позволяет фактически реализовывать ее "лениво" - т.е. список содержит только те значения, которые реально необходимо отобразить на ленте. Причем, если из ленты убраны значения, размер списка можно сократить по некоторым правилам.

Пустые элементы в списке можно обозначать как `None` или использовать любой другой элемент, такой как строковый литерал "_"., так как контейнер список позволяет так делать.

Все операции осуществляются при помощи курсора -- здесь для АТД прослеживается почти однозначное соответствие в занятии по связным спискам курса ООАП.

Альтернативным решением будет являться дву-связный список (дву- так как курсору необходимо перемещаться в обе стороны примерно одинаково часто). У двусвязного списка есть, в теории преимущества, например, при вставке в начало (для двусвязного списка это O(1), список в `Python` насколько я знаю, является массивом указателей, и в теории вставка должна быть мнедленее, на практике однако эта структура данных оптимизирована и вероятно будет работать быстрее, чем вручную созданный вариант двусвязного списка).

## Пример 5

Для реализации симуляции случайной поездки из проекта Автопарка на `Django`.
Один из вариантов симуляции поездки, выбрав случайные 2 адреса в 2 разных городах и далее:

- Расчет угла направления движения в сторону цели
- Выбираем случайное направление при угле в 45 градусов, расчитываем координату из соображения, что проходит 1 минута и машина движется со случайной скоростью (если не получется, расширяем угол).
- Проверяем по API через сторонний сервис, возвращается ли координата пути, если да, то записываем координату.
- Повторяем пока машина не окажется в месте назначения.

Таким образом, весь путь будет представлять собой следующее:
Словарь:

- авто: значение id
- водитель: id_водителя
- путь: [Point1, Point2, ...]

Структура Point будет следующая:

```python
@dataclass
class Point:
    timestamp: datetime
    latitude: float
    longitude: float
```

Этой информации в целом достаточно, чтобы полностью характеризовать поездку, однако если нам нужны такие параметры, как скорость и время в пути, по имеющимся данным их можно расчитать (приблизительно, т.к. по факту между 2 соседними координатами будет прямая линия, в реальности это не так). Тогда при доступности информации, можно расширить модель:

- путь: [(Point1, PathStatus1), (Point2, PathStatus2), ...]

```python
@dataclass
class PathStatus:
    vehicle_speed: float
    total_distance: float
    total_time: timedelta
```

Такую информацию также достаточно легко записывать в БД и отображать на картах путь, также такой подход облегчает сбор статистики по поездкам, без необходимость дополительных расчетов.

## Выводы и размышления по определению абстракции Дейкстры

Как мне кажется, новый уровень мышления, о котором говорит Дейкстра - это то, что возникает когда мы выражаем поставленную проблему на некоем описательном языке, как конечный набор условий и необходимый результат. При этом мы одновременно:

- Отбрасываем все лишние для решения задачи подробности.
- Связываем некоторые понятия этой модели с какими-то программистскими сущностями. Например, с какой либо конкретной структурой данных (например список, массив, словарь -- важно отметить, что эта структура данный понимается, в общем, без привязки к конкретному языку программирования).

Так как полученная нами модель избавлена от лишнего и имеет ограниченный набор характеристик и условий работы, описать ее устройство и поведение становится значительно проще, ведь мы уже ушли от "реального мира" и можем рассуждать уже непосредственно на уровне понятий, таких как алгоритмы и структуры данных. В этом и будет заключатся точность нашего рассуждения, когда мы одновременно не ограничены ненужными "подробностями реального мира" и при этом не связаны реализацией в конкретном коде или даже языке программирования.

В целом это занятие напоминает мне еще раз, насколько важно при планировании проекта рассматривать все подходы именно на третьем уровне мышения, который как раз наиболее близко связан с абстракциями, так как этот уровень размышения является самым "чистым", и тут наиболее легко применять алгоритмическое (или может даже математическое) мышление. И только после адекватного и точного решения задачи на этом уровне можно приступать к ее реализации непосредственно в коде.
