# Hard Work - LSP с точки зрения FP

Нужно сказать, что на текущий момент я ещё не использую функциональный код
для серьезных/рабочих проектов, т.к. только пытаюсь освоить использование ФП для 
реального применения. Но тем не менее, думаю, что могу вычленить несколько примеров для данного занятия.

## Пример 1

Думаю, классический пример функций, которые предоставляют полиморфный интерфейс,
это функции высшего порядка, такие как например Map.
Map как раз устроен так, чтобы взаимодействовать с любыми функциями, которе валидны
для применения на элементы списка:

```ocaml
let rec map f = function
  | [] -> []
  | h :: t -> f h :: map f t
```

Её тип:
`val map : ('a -> 'b) -> 'a list -> 'b list = <fun>`

При желании можно создать более "узкоспециализированную" функцию, передав в неё функцию
для преобразования списов.

```ocaml
let map_succ = map (fun x -> x + 1)
```

Её тип:
`val map : int list -> int list = <fun>`

А вот map для деревьев потребуется уже другой реализации.
(интересно, возможно ли сделать более обобщенный тип)
```ocaml
let rec map_tree f = function
  | Leaf -> Leaf
  | Node (v, l, r) -> Node (f v, map_tree f l, map_tree f r)
```

Но при этом, несмотря на то, что этот map применяется на разные типы данных, мы всегда
ожидаем одинаковое поведение.

## Пример 2

Также, как приводится в примере в занятии, в реазилации функции сортировки модуля `List`
в  OCaml также также используется ожидаемый интерфейс:

`val sort : cmp:('a -> 'a -> int) -> 'a list -> 'a list` 

Лейблированная функция cmp как раз и будет отвечать за сравнение при сортировки,
возвращая -1, 0 и 1.
Ключевая особенность, которая, как мне кажется, имеет отношение к LSP-принципу, это то,
что разные реализации сортировок имеют точно такой же интерфейс:

```ocaml
val stable_sort : cmp:('a -> 'a -> int) -> 'a list -> 'a list
val fast_sort : cmp:('a -> 'a -> int) -> 'a list -> 'a list
val sort_uniq : cmp:('a -> 'a -> int) -> 'a list -> 'a list
```

Таким образом, поведение всех сортировок в стандартной библиотеке ожидаемо для программиста.

## Пример 3

Возможно, пример того, как `полиморфные типы` будут использоваться схожим образом с тем,
что ожидается от использования LSP.

```ocaml
type `datasource = [ `Csv | `Xml ]

let save = function
  | `Csv -> ... (* сохранение в csv *)
  | `Xml -> ... (* сохранение в xml *)
```

Если нам нужно расширить список мест для сохранения данных, LSP предполагает, что он должен быть совместим 
с предыдущим, только расширяя его, но не приводя к исключениям при том же использовании:

```ocaml
type `datasource = [ `Csv | `Xml | `Xlsx ]

let save = function
  | `Csv -> ... (* сохранение в csv *)
  | `Xml -> ... (* сохранение в xml *)
  | `Xlsx -> ... (* сохранение в xlsx (excel) *)
```

## Пример 4

Система модулей в OCaml позволяет создавать интерфейс при помощи сигнатур, и затем 
создавать реализацию на его основе, что весьма напоминает то, как это работает в ООП.

Например, можно создать сигнатуру для Очереди, и затем реализовать от неё конкретные типы Очередей:

```ocaml
module type QueueSig = sig
  type 'a t
  val empty : 'a t
  val enqueue : 'a -> 'a t -> 'a t
  val dequeue : 'a t -> ('a option * 'a t)
end

module SimpleQueue : QueueSig = struct
  type 'a t = 'a list
  let empty = ...
  let enqueue x q = ...
  let dequeue = function ...
end

module LimitedQueue : QueueSig = struct
  type 'a t = 'a list
  let empty = ...
  let enqueue x q = ...
  let dequeue = function ...
end
```

## Выводы

На удивление, многие принципы, которые вседа казалось относятся только к ООП программированию,
оказываются намного более общими. Поэтому понимание принципа "подстановки Лисков" как "не удивляйте других программистов!"
теперь намного понятнее мне (особенно по сравнению с тем, как строго его принципы выражаются в отношении ООП).
И если вдуматься, действительно, LSP действительно "всего лишь" говорит нам о том, как органически 
должна развиваться програмная система: новые блоки функционала становятся поверх уже существующих, всегда
только добавляя новое, но без необходимости "ломать" и "пересобирать" всё заново.
