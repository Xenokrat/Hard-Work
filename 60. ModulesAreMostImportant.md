# Hard Work - Модули важнее всего

## Идеи для реализации "Одна реализация, множество интерфейсов" на языке `Python`.

В целом, использование протоколов `typing.Protocol`, по крайней мере для `mypy` позволяет 
задавать интерфейс в том числе и для модулей.

Так, например, мы можем сделать реализацию кода в `_module.py`

```python
# _module.py
# Представим, что здесь прописана реализация
def exec_select() -> None: pass
def exec_update() -> None: pass
def exec_delete() -> None: pass
```

Далее мы можем использовать реализованный код,
например, разбив его на модули, для того, чтобы ограничить использование
тех или иных функций (способа сделать функции приватными на уровне модуля в `Python` увы нет).

```python
# module1.py
from ._module import exec_select
```

```python
# module2.py
from _module import (
    exec_delete, 
    exec_select,
    exec_update
)
```

Для реализации "динамической архитектуры приложения" есть множество подходов:

- Можно запускать приложения как команду с агрументами
- Можно использовать переменные окружения.

Ни тот ни другой вариант не является особенно элегантными.

```python
import os

if os.getenv("USER") == "ADMIN":
    import module2 AS query_module
elif os.getenv("USER") == "ADMIN":
    import module1 AS query_module
else:
    raise ImportError("Не указан тип пользователя")

```

Пример аннотирования модулей при помощи протоколов:

```python
class ReadOnlyUser(Protocol):
    def exec_select(self) -> None: ...

class AdminUser(Protocol):
    def exec_select(self) -> None: ...
    def exec_delete(self) -> None: ...
    def exec_update(self) -> None: ...

def some_action(module: ReadOnlyUser) -> None:
    module.exec_update()
```

## Пример 1

Теоретически, если бы мы имели двух типов пользователей в системе, которая взаимодействует с БД, например:

- Администратор, который имеет полный доступ к БД.
- Аналитик, который имеет права только для чтения.

То мы можем иметь отдельный модуль с реализацией выполнения запроса к БД.
Так как сам способ выполнения запроса будет иметь одинаковую реализацию, то
мы можем использовать код этой реализации в двух интерфейсах для разных типов пользователей.

Сама (не-)возможность выполнения определенных типов запросов при этом будет зависеть от того,
какие запросы будут передавать в класс для того, или иного типа пользователя, с обязательной валиадией.
Но при этом, все эти вопросы не будут входить в обязанности модуля, который именно выполняет запрос к БД.

## Пример 2

Можно придумать модуль, который реализует различные инструменты `utils.py`, например, для
замера производительности кода.
И, скажем, у нас есть 2 варианта использования этого модуля:

- Используем его, как инструмент только для замера скорости выпонения функции.
- Используем его, как инструмент для подробного анализа 
(нагрузка на систему, количество вызываемых функции, цикломатическая сложности и т.д.), т.е. `verbose`.

Используя таким образом разные способы импортирования (например, можно в условной конструкции, которая определяет
как импортируется модуль, указать булевый флажок VERBOSE=True), например, при запуске приложения, мы можем получать
разное поведение программы, при этом используя реализацию одного и того же модуля. (и далее иметь дело с интерфейсом
"упрощенного варианта" программы, или, напротив, более подробного).

## Пример 3

Этот пример я не особенно уверен, насколько релевантен, однако
пример в занятии с общей схожестью Стека с Очередью (если мы заменем в Стеке `pop()` и `push` на `remove()` и `add()`)
натолкнула на мысль, что реализация стандартной библиотеке, содежращей функции для действия с файловой системой
в целом имеет одинаковую реализацию (по крайней мере то что нам видно при импортировании модуля) для разных ОС.

Т.е. интерфейс для управления файловой системой для `Linux` и интерфейс для управления файловой системой `Windows` будет
одинаково основан на библиотеке `pathlib` в `Python`.


## Выводы

Из всех занятий Hard-Work эта идея, наверное, одна из самых сложных для восприятия, по крайней мере для меня.
Я дейсвительно привык думать о модулях, просто как о способе органиции кода и пространстве имён.
Такой подход к написанию программ, думаю, будет довольно затруднительным для меня. Однако если анализировать уже
готовые приложений, можно действительно выделить такие отношения между модулями/данными которые будут
очень близкими к пониманию модулей как своего рода классов, но только с потенциальным отношением "многие ко многим",
когда реализация кода может давать нам потенциал для использования её в разных интерфейсах. Все эти размышления, как
мне кажется, могут заставить нас пересмотреть огранизацию кода в проекте и использовать модули как полноценные единицы (объекты)
программы как совокупности элементов (библиотеки), части которой могут переиспользоваться, причем не только реализации
функционала, но и её интерфейсы.
