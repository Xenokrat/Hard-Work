# Hard Work - Триплы Хоара

## 1. Как мы можем изменить этот код, чтобы постусловие оставалось истинным?

```c
{ true }
a = 10;
{ a > 1 }
b = 42;
{ a > 1, b > 1 }
c = a + b;
{ c > 1 }
```

### 1.1

Можем сократить список предусловий. Какими бы ни были `a` и `b`, `c` всегда будет >1,
поэтому первые строки избыточны:

```c
{ a > 1, b > 1 }
c = a + b;
{ c > 1 }
```

### 1.2

Если a > 1 и b > a, то тогда b > 1:

```c
a = 10;
{ a > 1 }
b = 42;
{ a > 1, b > a }
c = a + b;
{ c > 1 }
```

### 1.3

Чтобы c было больше одного, достаточно чтобы a или b были больше одного, и второе
значение было неотрицательным.

```c
{ true }
a = 10;
{ a > 1 }
b = 42;
{ a > 1, b >= 0 }  // b - неотрицальное
c = a + b;
{ c > 1 }
```

### 1.4

Можем использовать модули следующим образом:

```c
{ true }
a = 10;
{ |a| > 1 }
b = 42;
{ |a| > 1, |b| > 1 }
c = |a + b|;
{ c > 1 }
```

В этом случае постусловие также выполняется (модули у a и b нужны, чтобы значение суммы по модулю не оказалось меньше 1).

### 1.5

Можем в конце концов напряемую задать заранее, что сумма a + b > 1.

```c
{ a + b > 1 }
c = a + b;
{ c > 1 }
```

## 2. Заполнить пустые места правильными условиями

Нам нужно обратно выстроить процесс предусловий, чтобы понять как прийти в итоге к заданному постусловию.
Т.е. по сути здесь мы решаем уравнения с 3 неизветсными, чтобы прийти в итоге к `d = 5`.
```c
{ a = 0 }
b = 2 - a;
{ b = 2 }
c = b * 2;
{ c = 4 }
d = c + 1;
{d  =  5}
```

## 3. Выводы

После использования подхода логики Хоара для использования
ее в связи с созданием методов классов начал замечать, что неосознано использую ёё
не только в ООП, но и при написании обычных функций. В случае, когда программа
представляет собой последовательность инструкйи, полезно представлять её как цепочку,
состоящую из типлетов `предусловие-команда(побочный эффект) - постусловие` каждый раз, когда
мы имеем дело с каким-то состоянием. При таком размышлении мы можем в значительной степени
убедиться, что мы спроектировали программу правильно.
