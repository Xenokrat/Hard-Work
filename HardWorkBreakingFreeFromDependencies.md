
# Hard Work - Избавляемся от зависимости от зависимостей

## 1. Зависимость фреймворка

В одном из `Docker` контейнеров имеем планировщик который вызывает скрипт для формирования и отправки отчетов (как для клиентов, так и внутренних).
Можно ли считать, планировщик (библиотека `schedule`) зависит от воркеров с отчетами?
Думаю да, если любое отклонение в формировании отчетов (например, нет коннекта к БД) по умолчанию сломает всю последовательность работы.
Для управления этим обычно добавляем блоки `try -- catch` там где могут возникнуть проблемы, и добавляем ретраи (например несколько попыток переподключиться при потере соединения).
В этом примере это осознанное решение, так как источники проблем понятны.

## 2. Зависимость расшаренного формата

Сервис для формирования отчетов из данных в БД использует в качестве настроечного файла формат `.YAML`. Что-то вроде:

```yaml
date_range:
  - 2023-07-30
  - 2023-07-31
stages:
  - stage: Агрегация 1
    tasks: 
    - search_aggregation_1
    - shelf_aggregation_1
  
  - stage: Агрегация 2
    tasks:
    - shelf_aggregation_2
```

Правильность формата конфига как с точки зрения формата `yaml` так и смысла программы проверяется при помощи `Pydantic` (хотя если задуматься, тут получается другая зависимость, теперь от сторонней библиотеки).
Правильность заполнения конфигурационного фала уже остается на совести пользователя :), не так много можно сделать непосредственно здесь (может я ошибаюсь).
Здесь можно сказать, что тот кто записывает действительно зависят друг от друга, но эта зависимость через установленный формат.
То есть оба должны соблюдать установленные форматом правила и договоренности. Также можно сказать, что в примере с API, они оба должны соблюдать какой-то обговоренный заранее интерфейс.

## 3. Зависимость зависимости

В программе для мониторинга поступающих в БД данных, имели класс `Monitoring`.
В этом классе имелись методы для различных проверок.
Также в `Monitoring` использовалась переменная класса `PLATFORMS` (сет из строковых значений) с предварительно заданными значениями площадок, по которым нужно сверять значения для мониторинга.
При работе программы, если внутри БД встречалась новая площадка, то она добавлялась в эту переменную.
Проблема была в том, что не всегда эти новые площадки успевали появляться во всех таблицах БД и часто мониторинги запускали ложную тревогу.
Т.е. зависимость проявлялась в том, что через `PLATFORMS` одни мониторинги могли влиять на работу других.
Решение здесь было довольно простым -  `Monitoring` стал абстрактным классом, от него наследовались, например `SearchPositionMonitoring` и т.д. и у каждого из них была своя переменная с площадками.

## 4. Зависимость краша

Снова в скрипте для формирования отчетов недавно был добавлен следующий механизм:

- Базово ресурсы БД очень низкие.
- Перед формированием отчетов запускается функция (как контекстный менеджер), чтобы через API БД увеличить ресурсы.
- В конце снижаем ресурсы обратно до низких значений.

```python
@contextmanager
def upscaling() -> None:
    try:
        url = "url"
        upscale = {
            "minTotalMemoryGb": 360,
            "maxTotalMemoryGb": 360,
        }
        response = requests.patch(
            scale_url,
            json=upscale,
        )
        assert response.status_code == 200
        time.sleep(1200)
        yield
    finally:
        downscale = {...}
        response = requests.patch(
            scale_url,
            json=downscale,
        )
```

- Помимо обычных проблем с подключением здесь зависим также от того, что хотя по ответу от `API` ресурсы будто-бы увеличиваются сразу, по факту это происходит только через некоторое время.
- Из-за этой зависимости весь процесс может крашнуться, так как ресурсов базово недостаточно, а узнать точно когда они увеличились не получается.
- Решали проблему чисто интуитивно, подбирая время задержки после увеличения ресурсов и перед запуском работы.

## 5. Зависимость перебрасывания

Компания, в которой я работаю, занимается сбором данных приложений доставок.
Для парасинга таких приложений (в том числе в различных странах) используются прокси.
Естественно возникают ситуации, когда по какой-либо причине через прокси нельзя подключиться к конкретной точке приложения.

Поэтому был добавлен механизм, который, в случае нескольких неудачных попыток подряд, переключит прокси на запасные.
Наверное, нельзя сказать, что это было осознанно запланированное решение в нашем случае, так как этот механизм был добавлен только после возникновения проблем в подключениями.
Как я считаю, это как раз будет пример если не избавления, то снижения влияния зависимости, так как "запасные варианты" повышают надежность сервиса.

## 6. **Зависимость инверсии**

В скрипте, который формирует аналитические отчеты, все процедуры для формирования того или иного отчёта (или других действий) упаковываются в абстракцию как этапы (класс `Stage`), чтобы таким образом, модули / классы более высокого уровня могли, не зная деталей реализации каждого отчета, запускать их формирование, просто вызвав метод `execute_stage()`:

```python
def process_stages(self, date: datetime) -> None:
    for stage in self.stages:
        log.info(f"Processing stage: {stage.stage}")
        stage = Stage(
            name=stage.stage, commands=stage.tasks, 
            engine=self.__async_click_engine, date=date
        )
        stage.execute_stage()
```

Тут сложно сказать, избавляет ли такая абстракция от зависимости. С одной стороны мы можем подставлять любые объекты, которые реализуют интерфейс `Stage`, и с этой точки зрения мы не зависим от конкретных деталей реализации.
С другой стороны, естественно, модули / классы более высокого уровня (которые вызывают `Stage`) зависят от того, насколько правильно внутри он реализован -- и никак не гарантируют отсутствие ошибок. Обеспечиваем отсутствие ошибок на стадиях мы уже совсем другими способами (скорее неосознанно, так как мы просто стремимся, чтобы программа работала без ошибок, а не сознательно разрешаем зависимости).

## 7. Зависимость зацикливания

В реализации симуляции Машины Тьюринга имеется 2 объекта:

- Класс самой машины `TuringMachine`.
- Класс `Worker` - для реализации отдельного треда, который существует в процессе работы машины, чтобы иметь возможность управлять этим процессом (например остановить выполнение нажатием кнопки).

Транзитивность будет заключаться в том, что `TuringMachine` запускает тред с воркером, т.е. воркер зависит от машины. Но и также впоследствии машина теперь уже является зависимым от воркера объектом.
В моем случае решение в том, чтобы оба объекта зависли от класса более высокого уровня.
Вместо того, например, чтобы `TuringMachine` и `Worker` имели взаимные ссылки друг на друга, они связаны через класс `TuringMachineAPP` .

В конечном счете, если важное свойство `A` зависит от влияния того же `A` на другой объект, то систему нужно перестроить так, чтобы за это свойство отвечал объект более высокого уровня (по крайней мере я так это понимаю).

## 8. Зависимость высшего порядка

Использовали для работы с данными питоновскую библиотеку `Pandas`.
У `Pandas` имеется метод для присоединения таблиц, аналогичный обычному SQL `join`. В один момент столбец, по которому делали join, стал содержать значения как множества (`set`).
Но `Pandas` для `join` опять таки использует встроенную функцию питоновского хэширования, которая не работает на изменяемых типах данных, таких как `set` поэтому это изменение привело к ошибке при работе программы.

Таким образом мы зависели от реализации алгоритма `join`а.
Для исправления выбрали чисто интуитивно первое решение - не использовать в таблице изменяемые типы данных для столбцов, по которым возможен `join`.
При необходимости преобразовываем данные в НЕизменяемые (`frozenset`).

## 9. Зависимость большинства

Этот пункт было труднее всего понять :).
В контексте примера в обучающем материале, если 4 подсистемы всегда голосуют за один вариант, а пятая нет, это не значит на 100% что большинство будет право, ведь могла иметь место какая-нибудь распространённая когнитивная ошибка у программистов, или неочевидная проблема.
И теперь даже частное исправление не меняет ситуацию, ведь вся система зависит от мнения большинства.

Самым близким примером в моем опыте будет использование языковых моделей (`nlp`) для вычленения названий брендов товаров из их полного названия в приложениях доставки библиотеки вроде `spaCy` и `nltk`.
Хотя в среднем они справляются неплохо с этой задачей, существуют сложные для таких моделей примеры названий, в которых например будет слово `Сыр` с большой буквы в начале. И все эти модели каждый раз будут возвращать `Сыр` как правильный вариант названия (вместо условного `Ламбера`).
Это проблему можно решить  тюнингом моделей, но заканчивалось чаще всего тем, что человек дополнительно просматривал результат работы :).

## Общие выводы

Как мне кажется, вопрос зависимостей не столько в том, что `A -> B`, значит 100% `A` зависит от `B`, столько в том:

1. Какое свойство `A` зависимо? Важно ли оно в конкретной ситуации?
2. Насколько я могу управлять этой зависимостью?
3. Есть ли у меня альтернативный выбор? Приводит ли неполадка в `B` всегда к крашу программы.

В примере старого сайта, где на всех страницах фон задается отдельно, зависимость будет в том, что функциональность его (я предполагаю, что фон должен быть одинаковым на всех страницах) будет определяться каждым элементом отдельно, и непорядок в одном, значит некорректность состояния сайта в общем.
Этот приведенный выше пример показывает, что вопрос зависимостей не всегда очевидный и однонаправленный. Каждая ситуация индивидуальна и нужно определять для себя ключевые свойства системы, для которых наиболее важно контролировать зависимости.
