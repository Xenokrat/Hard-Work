# Hard Work - Компромисс между возможностями и удобством 

## Пример 1

Пример из мира баз данных.
В качестве базы данных для передачи этих самых данных клиенту используем `PostgreSQL`.
И также большинство потребителей данных предпочитают получать эти самые данные в денормализованном виде,
так как им проще загружать их так напрямую себе, например в BI-систему.
По этой причине, получаются очень "широкие" таблицы, данные в которых хранятся неэффективно (напрмер, множество одинаковых строковых записей названия продукта вместо айдишника).

В связи с этим довольно тяжело поддерживать такие таблицы:

- удалять старые данные
- обновлять текущие значения
- добавлять данные за какой-то более ранний период
- и т.д.

Выполнять все эти действия над подобной денормализованной таблицей по мере её роста становится все сложнее (VACUUM данных занимает больше времени).
Поэтому возникла потребность в решении этой проблемы, которое как раз дало нам больше возможностей, при этом не сильно усложнив ETL-процесс.

Решением оказалось использование партиций, которые позволяют как бы создавать абсолютно изолированные друг от друга таблицы, которые при этом "скрыты" от потребителя.
При запросе в основную таблицу `PostgreSQL` может автоматически "понять", какую именно партицию(ции) использовать, и пользователь может и не знать о существовании отдельных таблиц.

При этом партиции дают хорошие возможности для более оптимизированного управления данными, так как мы работаем отдельно с изолированными таблицами.

Единственная сложность состоит в том, что `PostgreSQL` не может автоматически создавать новые партиции (мы используем дни для разделения данных).
Но эта проблема решается относительно просто, с введением скрипта для создания новых таблиц в автоматическую работу ETL-процесса.
(также возможно решение с использованием внутренних "триггеров" Постгреса, но я не тестировал это).

## Пример 2

Для выполнения отчетов для клиентов используем несложную программу на `Python`, которая делает следующее:

- Считывает из конфига названия нужных операций.
- По названию ищет соответствующие запросы в папке с `.sql` файлами, загружает raw SQL-запрос.
- Выполняя данный запрос, формирует нужные данные/отчеты для конечного потребителя.

Эта схема очень простая и удобная, особенно при стабильной работе, когда в SQL-запросах можно просто указать "взять данные за последнюю дату".
Периодически однако возникает потребность выполнить те же запросы с какими-то другими настройками, фильтрами, за другие даты.
Самый простой вариант - создавать под каждую ситуацию отдельный SQL файл, однако это не слишком практичное решение, т.к. порождает множество файлов, содержащих дублирующую информацию.

Поэтому (для расширения горизонта возможностей), мы придумали ввести дополнительный класс (который работает скорее как структура или словарь, т.е. датакласс).
Этот датакласс может прочитать из конфига все нужные настройки, и передать их в теперь параметризованные sql запросы.
Современные драйвера для взаимодействия с БД предоставляют удобный механизм для параметризации, в итоге на программу нам нужны только уникальные имена для каждого параметра, и 
мы можем использовать следующий код:

```python
@dataclass
class ParametersDataclass:
    cnt: int = 1
    cnt2: int = 2
    date: str = (datetime.now() - timedelta(days=1)).strftime("%Y-%m-%d")
    date_next: str = datetime.now().strftime("%Y-%m-%d")
    client_email_list: tuple[str, ...] = (
        ...
    )
    store_platform_list: tuple[str, ...] = (
        ...
    )
    dict = asdict
    # и т.д.
```

Таким образом, мы добавили простой механизм, который позволяет переиспользовать существующие запросы множество раз под разные ситуации.

## Пример 3

Имеем программу для `Slack` бота, который позволяет через чат в Слаке пользователю с доступом запросить данные заранее преднастроенный отчет с данными.
В целом это удобно, однако быстро возникает вопрос о том, что менеджерам бывает необходимо получить запрос с какими-то фильтрами, например по конкретным странам.
По умолчанию, нет возможности передать дополнительный агрумент при отправке команды из слака, однако его можно достать из тела оправленного сообщения.
Такой подход даст возможность пользователю параметризовать запрос на отчет.

```python
@app.command("/check_app_parsing")
def app_parsing_state_command(ack, say, logger, body):
    # Acknowledge command request
    ack("Fetching data from DB")
    app = country = app_filter = country_filter = ""

    # Новый код
    if body["text"]:
        try:
            app = body["text"].split(",")[0].strip()
            app_filter = f"AND store_platform = '{app}'" if app != "all" else ""
            logger.debug(f"check_app_parsing: APP {app}")
        except IndexError:
            pass
    # Новый код

    ...
    # Теперь мы можем передать вытащенный агрумент в функцию, которая использует его при формировании запроса в БД
    result = get_app_data(app_filter, country_filter)
    logger.info(result)
    say(result)
```

## Пример 4

Попробуем улучшить еще в одном аспекте программу бота Slack из предыдущего пункта.
Некоторые запросы через бота нужно выполнять постоянно, например перед ежедневным совещанием нужно проверить какие-то данные.
Естественно, можно поручить какому-то сотруднику выполнять эти запросы по расписанию, но горазо продуктивнее будет:

- Использовать уже существующие команды бота
- Выполнять их на бэкэнде без вмешательства человека
- Выполнять их по какому-то настроенному расписанию

Можно расширить существующий код при помощи питоновской библиотеки `schedule`.
```python
import schedule
import time

def run_schedule() -> None:
    schedule.every().day.at("05:30").do(daily_app_monitoring)
    schedule.every().day.at("05:30").do(daily_raw_monitoring)
    schedule.every().day.at("05:30").do(daily_upd_monitoring)
    while True:
        schedule.run_pending()
        time.sleep(1)
```

Дополним основную программу запуском отдельного треда, в котором будет осуществляться запуск этого расписания.

```python
def main() -> None:
    socket_handler = SocketModeHandler(app, SLACK_APP_TOKEN)
    app_thread = threading.Thread(target=socket_handler.start)
    schedule_thread = threading.Thread(target=run_schedule)

    app_thread.start()
    schedule_thread.start()
```

Дополнительно, этот код впоследствии можно будет расширить, модифицируя расписание из файла-конфига, вместо вписывания его код.

## Пример 5

Это пример из будущего опыта :). 
Имеем программу, которая выполняет серию операций в базе данных, включающую агрегирование данных, составление отчетов, передачу данных в другие БД и т.д., написанную на Python.
Ключевой особенностью этой программы является возможность задавать последовательность выполнения шагов, каждый шаг может объединять множество операций, которые возможно выполнять параллельно.
И при этом операции разделены между разными шагами, когда одна из них зависит от выполнения предыдущих.
Такая схема не идеальна. Более подходящей структурой был бы направленных граф из отдельных операций.
Каджый узел представлял бы собой операцию, причем направленные к ней ребра отражали бы её зависимоть от предыдущих операций.
Таким образом мы можем избежать сиутации, когда в пределах "шага" операция уже выполнена, но при этом "ждет" выполнения остальных операций в шаге.
Вместо этого, завершение операции "открывает" для выполнения операции, к которым ведут ребра, исходящие из этой самой выполненной операции (при условии, что нет других зависимых операций, или они также
выполнены).
Структура с графами, естественно, менее "удобная", чем простая блок-схема из действий.
Однако недавно я выяснил, что в `Python` есть встроенная библиотека `graphlib`, и в моих текущих планах попробовать реализовать простейший случай выполнения графа операций БД.

## Выводы

Главное, что я вынес из этого занятия, это описанная в нем, своего рода циклическая зависимость между сложностью и удобствами. 
Чем больше в систему "встроено" возможностей, которые могут сделать её создание менее удобной, тем зато больше этих "бесплантых"
горизонтов открывается впоследствии. Т.е. мы можем "купить" будущее удобство, прикладывая больших усилий в настоящий момент.
Вот поэтому в занятии рекоментуется думать об этой зависимости как о спекте или решетке.
В конце концов, при размышлении о дизайна проекта, нам нужно планировать, на каком компромиссе мы остановимся в отношении между "удобством" - "возможнстью" системы.
