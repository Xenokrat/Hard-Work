# Hard Work - Избавляемся от stateful через глобальное состояние

## Идея

Что-то похожее описанию (вроде бы), сейчас пытаюсь реализовывать на уровне приложения для составления аналитических отчетов. 
Суть этого заключается в том, что мы храним все настройки того, как составлять отчеты в таблицах БД/

Для этого удобно создавать настроечные таблицы в отдельной схеме БД,
изолированной от доступа для пользвателя (или с ограниченным доступом, например для менеджера можно дать возможность редактировать, например,
список приложений для отчетов, хотя это спорно).

Одни таблицы содержат, например, списки таблиц, которые нужно использовать для формирования отчетов, их названия, и пр.
Другие таблицы являются фильтрами, и могут содержать, например, списки айдишников, которые потом подставляются в WHERE-условие.
Таким образом, читая значения из них, можно формировать нужный SQL-запрос для выполнения уже в части БД, которая содержит аналитические данные.

Программа, при этом имеет возможность редактировать списки фильтров.
Например, какой-то магазин перестал обновляться (например, уже 30 дней), мы можем сразу исключить его из фильтров.

К такой схеме также легко добавить мониторинги, настроив на уровне БД автоматизацию (например, триггерами PostgreSQL или автообновляемыми мат.вью в Clickhouse).

На текущий момент это реализовано не идеально: в основном использую таблицы как фильтры, так как это проще всего реализовать,
использовать значения в таблицах как "рецепт" для составления корректного SQL-запроса довольно затруднительно (как пример, октрытый вопрос, как описывать правила для
JOIN'а нескольких таблиц, которые "участвуют" в "рецепте" для сборки отчета). 

При такой схеме программе достаточно прочитать "рецепт" составления нужного отчета из соответствующей таблицы, подставить названия таблиц и фильтры для них и выполнить
запрос, при этом практически исключается необходимость хранить какую-то информацию в переменных внутри программы, при необходимости можно описать правила для UPDATE значений в настроечных
таблицах по результатам выполнения программы.

## Выводы

Информация в этой заметке действительно противоречит тому, что я привык слышать о глобальном (расшареном) состоянии. Обычно принято говорить, что максимально правильно
локазизировать состояние в как можно более маленьких участках программы. Однако и держать в голове при этом, как состояние "размазано" по большому числу строк кода
также очень непросто. Видимо поэтому я интуитивно использовал подход с настроечными таблицами, который позволил мне одновременно наблюдать все состояние,
просто открыв таблицу в БД. Также осознаю, что описанная мной схема не идеально, и для процессов формирования данных еще лучше подошел бы направленный граф.
Схемы движения данных даже часто принято описывать в таких графах (например, как задачи в Airflow), но идея переместить туда вообще всё состояние для меня новая и интересная.
