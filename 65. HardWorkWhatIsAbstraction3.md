# Hard Work - Что такое абстракция - 2

## Пример 1

Мы имеем облачный сервис с базой данных, у которого имеются 3 реплики.
Для эффективной работы мы вынуждены использовать их по-максимуму, однако это не так то просто.
Особенностью `Clickhouse` является то, что запросы легко могут привести к перерасходу RAM,
что приведёт к их падению (также в `Clickhouse` нет транзакций, что ещё сильнее усложняет процесс).
Поэтому мы должны нагружать ноды равномерно, не допуская при этом как "простоев" так и перенагрузки.

Ранее мы использовали достаточно очевидный подход: мы просто асинхронно запускаем по 3 запроса
на систему.
У такого подхода есть проблемы:

- Один или два запроса могут выполнится быстро, но ресурсы БД не будут использоваться, пока не закончится третий.
- При проблеме хотя бы в одном запросе, мы потеряем весь "этап".
- Также при проблемах не всегда просто определить, какой именно запрос был иточником проблемы и какие шаги
нужно предпринять для восстановления работы.

Если мы попробуем описать, как решить эту проблему на более высоком уровне, 
в голову приходят следующие соображения: более всего весь этот процесс похож на граф.
Если быть точнее, на *направленный асинхронный граф* (DAG).

```
               ---- E---\         
      ---B----/          ----H    
 A---/        -\         -/       
  \ --\         -\     -/         
   \   --C----------F-/           
    -\         --/                
      \     --/                   
       - D-/--------------- G     
```

В таком графе каждый шаг может направлять к следующей задаче, или даже нескольким, при этом
каждая задача также зависит от нуля и более предыдущих задач.

Тогда мы можем описать весь набор правил примерно следущим образом:

- В работе могут быть одновременно только 3 задачи (вообще нода вполне может выполнять и больше одной задачи, 
но чтобы быть в этом уверенным, нужно знать статистику по использованию ресурсов запросами, поэтому пока остановимся на 3 параллельных задачах).
- Задачу можно взять в работу, только если выполнены все задачи верхнего уровня, которые ведут к ней "стрелочки".
- При окончании задачи, берётся в работу самая верхнеуровневая задача, которая "доступна к выполнению" по предыдущему условию.

При реализации такого подхода мы скорее всего введём класс Узла, который содержит информацию о запросе, 
зависимые узлы, а также от каких узлов от зависит сам.

При этом описать граф относительно легко можно будет конфигурационным файлом:

```yml
- node: Task F
  query: "SELECT * FROM"
  depends_on:
  - B
  - C
  - D
  dependencies:
  - H
```

Таким образом, при реализации мы просто вопользуемся для создания алгоритма правилами,
которые мы описали на более абстрактном уровне.


## Пример 2

Допустим мы иммем необходимость перемещать большие файлы внутри нашей системы.
Например, с сервера на `S3-хранилище`, или с базы данных в `AzureBlob` и т.д.
В определенный момент времени все это было набором разрозненных скриптов под каждый конкретный случай.

Можем ли мы решить проблему на более высоком уровне?
Попробуем "абстрагировать" процесс в целом:

Скажем, что в общем случае у нас есть:

- Протокол передачи между системами, т.е. то что непосредственно осуществляет передачу между сервисами.
- Политика передачи файлов - это, например, происходит перемещение или копирование файла, 
используется ли стримминг, нужно ли сохранять заголовки и т.д.

При реализации можем создать абстрактный класс `Transfer` от которого мы унаследуем варианты вроде: 

- S3AzureTransfer : Transfer
- S3ServerTransfer : Transfer
- AzureS3Transfer : Transfer

(часто нужно 2 класса, чтобы передавать файлы в обе стороны: на пример из Azure в S3 и наоборот)

Также у Трансфера будет поле, которое будет отвечать за политику передачи, и это как раз будет семейство классов
`TsPolicy`

Так мы на более абстрактном уровне легко избавились от множества скриптов и свели их к одной программе, которую
легко можно расширять создавая наследников Трансфера и новые политики передачи.

## Пример 3

Допустим, у нас есть несколько команд для Slack-бота:
Мы можем запросить у бота какую-либо информацию, и получить ответ в виде сообщения в мессенджере.
В простейшем варианте, для каждой из команд отдельно создавался формат, и они были никак не связаны друг с другом.
Но по мере роста количества команд, стало заметно, что они имеют много общего в плане формата результатов:

Тут мы как раз можем подумать не на уровне конкретной команды, на более обобщенно.
Результаты команд бывают в целом 3 видов:

- Одно предложение.
- Список результатов.
- Таблица результатов.

Вполне можно ввести класс `Formatter`, который будет как-то отображать
полученный результат одинаковым образом.

На уровне реализации мы можем придумать алгоритм, который будет получать, например заголовки и список записей
и создавать к примеру ASCII-таблицу (также у Slack есть примитивный формат `mrkdwn`, "усеченный вариант Markdown).


## Выводы

Наконец могу сказать, что стал понимать абстракции не как что-то отвлекающее нас от решения задачи 
-- вроде зачем вводить все эти интерфейсы или абстрактные классы заранее,
быстрее написать код, который просто решит задачу?
Но вместо того, чтобы сразу бросаться решать задачу на уровне кода, мы можем найти и описать решение
на более чистом и понятном языке, который не зависит от особенностей языка или фреймворка, который
легко расширить или использовать его повторно, замечая похожие паттерны в разных проектах.
Также сразу становятся понятны наши намерения и подход к решению задачи, что может быть совсем не очевидно
просто из кода.
Находить хорошие абстракции может быть весьма сложно, но потраченное время
(если речь конечно не идет об одноразовом скрипте) окупится потом, когда нужно будет
читать, понимать и расширять функционал наших программ.
