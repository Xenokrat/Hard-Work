# Hard Work - Зачем вам NULL?

## Пример 1

Допустим, мы имеем значение положения продукта на полке - простое INT значение.
Если по какой-то причине это положение неизвестно, то можно поробовать использовать
невалидные значения положения вместо NULL - например `-1`.
Мне приходилось использовать такой подход, когда мне нужно было обозначить "полностью отсутствующие на полке" продукты,
и при этом в начальной настройке поля вообще не было доступа для использования `NULL` значений.

(Но тут всегда нужно быть осторожым, с случае если кто-то захочет, например, оценить среднее положение,
тогда наличие значений `-1` может исказить результат, при этом ошибка не будет явно заметна).

## Пример 2

Мы имеем поле с ценой продукта. При записи цены встречаются 3 ситуации - обычная запись цены,
запись цены == 0 и отсутствие записи, что сейчас обозначается как раз `NULL`.
(Запись отрицательной цены невозможна, так как используется тип поля UInt32).
На самом деле и запись 0 и NULL некорректны, но по разной причине - NULL это когда не удалось получить значение вообще, а
0 это явная ошибка при получении значения (например, при отрицательном значении).

В этом случае можно полностью избавиться от `NULL` если мы создадим поле с типом `Enum` (или `LowCardinality` в `Clickhouse` например).
Это поле будет содержать дополнительную информацию о записи цены, например:

- 1 - OK
- 2 - INVALID VALUE
- 3 - UNKNOWN VALUE

Тогда можно полностью избавиться от Null в самом значении столбца цены. Новая колонка при этом достаточно "лёгкая" и не влияет на производительность.

## Пример 3

Если у нас есть поле "Скидка" (допустим `Float`), то отсутствие скидки могло бы быть обозначено `NULL`.
Однако в данном случае можно вполне обойтись и без него и обозначить "без скидки" просто значением 0.0.
Если задуматься дальше, то у снижения цены на товар может быть больше причин, чем просто "скидка".
Например, цена может снизиться по программе лояльности, из-за уценки и т.д. Ранее я видел как для таких значений
каждый раз создавались новые колонки в базе данных.

Одакой, так же как и в примере выше мы можем ввести дополнительно поле, которое будет обозначать эту причину снижения.
При этом в самом `Float` поле, мы оставим тольлко возможность указать 0.0 без `NULL`. Пример полей:

- 1 - FULL PRICE
- 2 - DISCOUNT
- 3 - LOYALTY DISCOUNT
- 4 - UNKNOWN

(NOTE: тут нужно быть уверенным на 100%, что у снижения цены всегда может быть только единственная причина,
или по крайней мере значение снижения можно выразить одной цифрой (тогда поле может быть DISCOUNT + LOYALTY)).

## Пример 4

`Clickhouse` по операции JOIN по умолчанию вообще не использует NULL.
Так как большинство операций `JOIN` производятся по значениям `id` тех или иных сущностей, это не составляет
большой проблемы. После, например, `LEFT JOIN` остаются значения в правой таблие с `id == 0`, которые легко отсеять.
В случае айдишников, значение "ноль" 100% не является корретным, и при этом `id` не являются целью (обычно) для расчёта
разных статистик, вроде среднего значения, поэтому в данном случае `NULL` является лишним.

## Пример 5

Рассмотрим ситуацию, когда мы добавляем клиенту в БД новое значение в уже существующую таблицу.
Например это поле "Доступность товара".
В этом случае `NULL` будет находится во всех значениях перед датой добавления этой новой сущности.
Так как это булево поле, то в нём будет фактически 3 значения - 0, 1 и NULL.
Однако вспомнив занятие по булевым значениям, можем прийти к выводу, что более информативно будет поле типа `DateTime` - которое
будет означать примерно "последняя дата наличия товара".
Но можно ли тогда избавиться от `NULL` и в этой ситуации?
Я думаю, что для этого подходит значение `1 января 1970`, т.е. 0 по Unix-timestamp.
Этот подход прекрасно работает для значений, которые обновляются сейчас в реальном времени, так как позволяет легко произвольно регулировать
отсечку когда мы считаем что товар был доступен.

## Выводы

Интересный факт - в колнках в `Clickhouse` по умолчанию отстуствует поле `NULL` в любых типах данных.
Его можно "включить" при создании колонки, однако на самом деле БД не использует `NULL` в самом поле,
но создаёт дополнительную скрытую колонку с флажками, которые говорят, являются ли значения NULL или нет.

Но это же как раз то что предлагается в данном занятии! Но при этом если мы сами создаём доп.поле, то ничто не ограничивает
нас от того, чтобы закодировать больше информации, а не только бинарное NULL | NON-NULL.

Хотя откровенно говоря, часто NULL будет очень удобным для некоторых аналитически операций -
например при взятии средней цены нам не нужно будет задумываться о исключении нулей (если они не валидное значение), NULL
исключается самой БД. На самом деле очень легко не учесть при обращении к информации дополнительные поля, особенно если
человек не знаком с такой практикой.

Но в то же время просто NULL даёт крайне мало информции, фактически не объясняя отсуствия значения.
При этом расширение модели данных дополнительным полем (или даже какой-то метод включения информации в само поле)
поволяет "дешёво" обогатить модель полезной информацией.

