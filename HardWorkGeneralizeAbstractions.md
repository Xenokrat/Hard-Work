# Обобщаем проектные абстракции

## 1. Примеры потенциального сокращения иерархий классов

### 1.1 Пример

В занятии, посвященно абстракциям, в качестве примера случая, когда 2 сущености с одинаковой реализацией, но разной спецификацией нужно разделить, были в качестве примера 2 класса для работы с БД - `PostgreSQL` (классическая реляционная SQL) и `Clickhouse` - `OLAP` БД.

Возможно, лучшим решением будет как раз оставить связь этих 2 классов через подобие интерфейска. Назовем такой интерфейс `Queriable`.

```python
class Queriable(Protocol):
    def execute_query(
        self, 
        params: list[Any] = [],
    ) -> None:
        ...
```

Тогда для всех последующих классов, которые реализуют этот интерфейс, мы можем использовать этот класс-протокол как миксин.

```python
class ClickhouseDB(Queriable): ...
class PostgresqlDB(RelationalDB, Queriable): ...
# Также возможен такой вариант
class FileDB(Queriable): ...
```

### 1.2 Пример

Если у нас имеется иерархия классов, которые представляют собой аналитические отчеты, то на первый взгляд кажется, что разумно составить ее, начиная аж от некоего абстрактного отчета

```python
class Report(ABC):
    @abstractmethod
    def __init__(self):
        pass

    @abstractmethod
    def send_report(self) -> None:
        pass

    @abstractmethod
    def create_report(self, report_data: pd.DataFrame) -> None:
        pass
```

Далее вроде как можно создавать различные реализации подклассов, для:

1. Каждого типа источника данных и того, как именно создаётся отчет
2. Куда именно и каким способом отчет отправляется

```python
class PostgreSQLEmailReport(Report):
    ...

class CSVEmailReport(Report):
    ...

class CSVSlackReport(Report):
    ...
```

Однако потенциально, такие иерархии быстро станут очень сложными, ведь у нас потенциально есть сочетания любого типа БД с любым способом отправки.
Тогда, вероятно, возможно также использовать механизм с миксинами и с этом случае.

```python
class ReportCreator(Protocol):
    def create_report(self, report_data) -> None:
        ...

class CSVReportCreator(ReportCreator):
    def create_report(self, report_data) -> None:
        """Реализация"""

class DataframeReportCreator(ReportCreator):
    def create_report(self, report_data) -> None:
        """Реализация"""
```

Аналогично поступим и с отправкой отчетов:

```python
class ReportCreator(Protocol):
    def send_report(self) -> None:
        ...

class CSVReportCreator(ReportCreator):
    def send_report(self) -> None:
        """Реализация"""
```

Тогда классы будут создаваться с использованием множественного наследования от 2 иерархий выше.

## 2. Подход interface dispatch

В `Python` как языке с динамической типизацией, нет ограничений по типам отъектов, которые можно использовать в функции.
Однако все же имеется набор инструментов, связанный с возможностью аннотирования типов. Один из таких инструментов -- это класс `Protocol` из модуля `typing`.
Этот класс позволяет создавать что-то вроде интерфейса, в виде класса с перечислением методов и их сигнатуры.

Скажем, для первого примера можно использовать следующую функцию:

```python
def insert_report_into_postgresql(data, source: Queriable) -> None:
    report_data = source.execute_query(data)
    # тут дальше реализация вставки в Постгрес
    ...
```

В этом коде `mypy` выдаст предупреждение, если в качестве аргумента `source` будет передан класс, не содержащий метода `execute_query`.

Таким классом можно аннотировать аргументы функции, и хотя это никак не влияет на работу программы в рантайме, это позволяет линтерам (вроде `Mypy`) проверять реализует ли передаваемый аргумент все перечисленные в протоколе методы (т.е. Протокол - это инструмент для введения утиной типизации).

## 3. Примеры по Ясной Архитектуре

Здесь так получилось, что я по-видимому еще не проходил этот курс, поэтому будет смысл добавить примеры после.

## Выводы

Благодаря занятию узнал еще немного нового из абстрактной алгебры, не так уж и сложно, но обычно статьи не предлагают объяснения "на пальцах", в отличии от данного занятия :).

По факту, выделение отдельных подкатегорий объектов, которые обладают схожими характеристиками дает в значительной степени гибкость при создании иерархий классов.

С другой стороны, построение иерархий классов на основе "чем является" заметно проще на начальных этапах проектирования. Но впоследствии более полное осознание, что "какими общими свойствами обладает" является в определенное степени даже более предпочтительным способом задания классов.

Здесь, как ни странно, довольно удобно использование `Python` во первых, за счет поддержки множественного наследования, благодаря которому можно расширять классы функциональностью за счет "примесей" (миксинов). Во-вторых, за счет динамической типизации, гибкое использование объектов в качестве агрументов, и при этом одновременно безопасность, при использовании инструментов аннотирования (которые встроены в язык) и линтеров.

(Сдедует отметить, что, на мой взгляд, хотя описанные выше преимущества `Python` значительны, языки со статической типизацией вроде `Java` также эффективно решают такие проблемы с архитектурой классов, в основном за счет использования устоявшихся решений, т.е. паттернов проектирования).