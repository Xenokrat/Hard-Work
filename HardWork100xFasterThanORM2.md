# Hard Work - Ускоряем код фреймворков в 100 раз. Часть 2

## Примеры не специфицированного поведения стороннего ПО

### Пример 1.1

Есть библиотека `Slack bolt` для создания пользовательских ботов для взаимодействия с API `Slack`.
У библиотеки имеются несколько способов для вывода ответа на пользовательские действия, такие как введение слэш-комманд.
В `Quickstart` часто 2 такие команды - `ack()` и `say()`. И в примерах они используются с одной и той же целью.
Однако, как оказалось, задача `ack()` - установить соединение для ответа на команду и если, например, использовать только `say()`, то в случае, когда запрос к БД длится больше пары секунд, сообщение оборвется без выведения каких либо ошибок.
Поэтому правильно использовать `ack()` чтобы сообщить пользователю, что запрос обрабатывается, и `say()` для собственно отправки основного ответа.

```python
@app.command("/check_raw_data")
def check_raw_data_command(ack, logger, say):
    # Acknowledge command request
    ack("Fetching data from DB")
    try:
        result = get_raw_data() # Сдесь запрос к базе данных
        logger.info(result)
        say(result)
    except Exception as e:
        logger.error(e)
```

Здесь можно сказать, что это моя вина, т.к. в одном месте мне все-таки удалось найти указание, что задача `ack` именно в *"acknowledge command request"*. Но документация `Slack` раскидана по множеству разделов и многие страницы содержат откровенно устаревшую информацию (например, все еще есть странички с инф. под старый API).

### Пример 1.2

Имеется очень популярная библиотека на Python для создания асинхронных запросов к `PostgreSQL` -- `asyncpg` (не ORM, только асинхронный драйвер для работы с БД).
До этого я в основном использовал ORM `SQLAlchemy` (который в том числе поддерживает `asyncpg` как драйвер).
В `SQLAlchemy` есть 2 способа параметризации запросов, это:

- передача позиционного аргумента, например - `$1`
- передача именованного аргумента, например - `:user_id_list`

```python
with Session(engine) as session:
  res = session.execute(sa.text("""
    SELECT *
    FROM table
    WHERE user_id IN :user_id_list, 
    """), {user_id_list: (1,2,3,)}
  )
```

Драйвер `asyncpg` поддерживает передачу аргумента по позиции, и key-value аргументов также как и `SQLAlchemy`, НО во втором случае невозможно использовать питоновский кортеж, так как это приведет к некорректному запросу (которую непросто понять сходу в асинхронном коде).
При этом единичное значение таким образом воспринимается абсолютно правильно.
(Важный факт, который я узнал, что даже при использовании `asyncpg` как драйвера в `SQLAlchemy`, последний параметризует запрос сам, не через драйвер).
Думаю, что мое предположение имело смысл, так как кажется логично, что параметризация запросов должна быть единообразной для разных фреймворков.

### Пример 1.3

В одной из рабочих программ, для чтения конфигурационных файлов использовался код, который считывал `YAML` файл, и преобразовывал его в список процедур, которые нужно выполнить для составления клиентских отчетов.
В методе, который это делает, не было описано, что будет происходить в случае, если пользователь передаст некорректный настроечный файл.
По логике, в таком случае программа не должна была отрабатывать, но по факту загружался дефолтный конфигурационный файл.
Такое поведение не было задокументировано, и привело в итоге к следующей ситуации.
Понадобилось внести немного скорректированный по параметрам конфиг, который только немного отличатся от дефолтного, но он был написан с ошибкой (в `YAML` как ни печально, легко пропустить лишний пробел).
По факту продолжал загружаться дефолтный конфиг, и на то чтобы понять, почему результаты не изменялись после модификаций времени ушло значительно много времени.

## Примеры включения пользовательского типа результата

### Пример 2.1

Имеем пользовательский дашборд для отслеживания информации по продажам продуктов.
В таком дашборде имеется фильтр по названию продуктов для пользователя, чтобы ему было удобно выбирать именно свои товары.
И вместе с этим значения id продуктов (`product_id`) также используется в дашборде при подсчете различных метрик.
(тут важно отметить, что существуют продукты с одним названием, но разными id, так как они находятся в разных сервисах доставок).
Сочетание `product_id -- product_name` очень легко получить единственным запросом к БД:

```SQL
SELECT DISTINCT product_id, product_name
FROM table
WHERE -- ... фильры
```

Однако для фильтра дашборда нужны только уникальные `product_name`, а для подсчета метрик в дашборде нужно сочетание `product_id -- product_name` (иногда только `product_id`).
Хорошим решением будет здесь для функции, которая делает запрос к БД на бэкэнде возвращать 2 значения - лист кортежей `product_id -- product_name`, + лист `product_name`, причем последний можно сразу вернуть как `set {}`, и при этом все это можно сделать за один SQL запрос.

### Пример 2.2

Одна из систем мониторинга для клиентов предполагала, что при запуске мониторинга будут проверяться, что на указанных площадках получены все данные с интересующих клиента ретейлеров.
Эти данные в целом возвращавшись через библиотеку для взаимодействия с БД как список кортежей.
Однако возникал следующий вопрос, как без лишних сложностей предоставить клиентам эту информацию в читаемом виде?
Довольно простое решение, вместо списка кортежей будем получать питоновский словарь, содержащий указанные данные.

```python
cursor = conn.cursor(
 cursor_factory=psycopg2.extras.RealDictCursor
)
return yaml.dumps(cursor.fetchall())
```

Затем можно преобразовать эту информацию в `YAML` формат, который довольно читабельный для пользователя (если нет множества уровней вложенности).
В результате можно получать информацию в виде:

```YAML
client_1
  - retailer_1
  - retailer_2
client_2
  - retailer_3
  - retailer_4
```

### Пример 2.3

Еще один из примеров изменения формата возвращаемых данных в пользовательском формате.
На фротнэнд требовалось передать данные для фильтра брендов пользователя по категории.
Стандартный способ сделать это, получить данные из БД используя `SELECT DISTINCT brand, category FROM ...` в виде:

```python
[
  ('brand1': 'category1'),
  ('brand1': 'category2'),
  ('brand1': 'category3'),
 ...
]
```

Однако в качестве БД мы использовали `Clickhouse`, у которого есть функция `groupUniqArray`, которая группирует уникальные значения в массив, удаляя при этом дубликаты, при этом работая довольно быстро (хотя и значительно нагружает оперативную память).
В результате формат данных преобразовался в

```python
{"brand1": ["category1", "category2", "category3", ...]}
```

который впоследствии было легко передать и использовать дальше.

## Выводы

После данного занятия, для меня стало понятно, что использование привычных инструментов, облегчающих работу программиста, таких как ORM, связано зачастую с серьезными недостатками.
Когда инструмент берет часть сложной / рутинной работы на себя, расплата за это будет заключаться в утрате контроля / эффективности / производительности, что неизбежно, так как:

- инструмент нуждается в некоторой "надстройке" для своей работы.
- инструмент должен максимально обобщать типичные случаи своего использования, что не подразумевает "тонкую настройку" в ходе работы.
- инструмент имеет свои особенности работы, которые также эффективны в максимально обобщенном случае (как в примере с сортировкой результатов по умолчанию), но не подходят для всех конкретных ситуаций.
Хотя в целом ORM может экономить много времени и позволяет разработчику быть более ленивым, умение при необходимости отказаться от его использования в пользу, например, прямых SQL позволяет быть более гибким и при необходимости получать ощутимый выигрыш в эффективности работы программы.
