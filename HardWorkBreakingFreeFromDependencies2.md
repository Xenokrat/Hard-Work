# Hard Work - Избавляемся от зависимости от зависимостей 2

## Пример 1

Использование внешней `Python` библиотеки `clickhouse-sqlalchemy` для управления БД `Clickhouse` и выполнения миграций.

### 1. Семантика

- **Зависимость сборки.**
С одной стороны, по отдельности библиотеки (наша и внешняя) самостоятельны и самодостаточны.
Однако корректность "сборки" окружения программы для clickhouse-sqlalchemy уже зависит от SQLAlchemy (также используемой в проекте), так как является надстройкой над билбиотекой и изменения затрагивают его работу.
Поэтому при создании рабочего окружения имеем зависимость сборки.

- **Зависимость в runtime.**
Динамическая зависиомоть проявлялась, например, при выполнении миграции с использованием `clickhouse-sqlalchemy` встречали проблему, что некая функция библиотеки использовала 2 аргумента, в то время как передавалось в нее 3 (баг, судя по теме в *issue* на `github`).
Таким образом, правильность работы нашего проекта зависит, например, от отсутствия ошибок в внутреннем устройстве библиотеки.

- **Зависимость функциональности.**
С точки зрения функциональности (выполнения всех поставленных перед инструментом задач) зависим от того, способна ли `clickhouse-sqlalchemy` создавать и выполнять миграции и корректные `DDL`(и другие) запросы.
В последнем в нашем случае могли убедиться только опытным путем.
Также при отсутствии на данный момент аналогичных библиотек, зависимость будет проявляться в отсутствии альтернативы, даже при возможности абстрагировать работу `clickhouse-sqlalchemy`.

### 1. Характеристики

Одно из условий использования ORM библиотеки - поддержка асинхронного движка для запросов.
С этой точки зрения зависимость имеется зависимость от реализации такого движка в `clickhouse-sqlalchemy` (была добавлена с последней версии библиотеки). Альтернативных решений с использованием `Python` на данный момент мы не встречали.

### 1. Допустимые изменения

В текущем состоянии `clickhouse-sqlalchemy` реализует не все возможности БД `Clickhouse`, (например, нет поддержки некоторых типов данных, проекций и т.п.).
С точки зрения используемых на текущий момент инструментов, библиотека поддерживает весь необходимый функционал, т.е. в текущих пределах зависимости (пока) нет.
Но с точки зрения суперспецификации, мы зависим от введения новых фич в библиотеку так как допускаем, что в будущем может использоваться новый инструментарий `Clickhouse`.

## Пример 2

Использование проекта для `Python` -- `Poetry` для управления библиотеками в проекте.

### 2. Семантика

- **Зависимость сборки.**
Да, зависим, так как `Poetry` в том числе выполняет функцию сборки проекта (сборки окружения).
Зависимость проявляется в отличии от стандартного использования `pip` + `requirements.txt` а также особого подхода при сборке контейнера `Docker`.

- **Зависимость в runtime.**
При условии отсутствия проблем со сборкой окружения, как раз динамическая зависимость отсутствует

- **Зависимость функциональности.**
Общая способность проекта функционировать (т.е. выполнять специфицированные задачи) не определяется `Poetry` как программой для управлением библиотеками проекта. Также `Poetry` может быть заменена другими аналогичными проектами (например `Pipenv` или даже использованием обычного `pip`) без всякого влияния на функционал проекта. В этой точки зрения никакой зависимости нет.

### 2. Характеристики

Если цель использования `Poetry` в проекте - это отсутствие конфликтов между библиотеками и воспроизводимость в любых условиях, то получается что мы имеем зависимость этих характеристик от приложения. Также можно отметить важность лёгкого использования для создания и корректной работы приложения внутри контейнера.

### 2. Допустимые изменения

Одно из условий использования библиотеки для управления зависимостями, это постоянство синтаксиса использования, например:
В старых версиях синтаксис добавления зависимостей для разработки.

```sh
poetry add --dev some_lib
```

В новых версиях (пока еще обратно совместимо)

```sh
poetry add --group=dev some_lib
```

В синтаксисе `Docker` будет иметь значение, какая версия используется,
когда будет удалена обратная совместимость, старый синтаксис приведет к ошибке при сборке контейнера.
Естественно, эта проблема решается использованием четко определенной версии программы.
(как мне кажется, изменение синтаксиса работы программы разработчиком будет уже относиться к суперспецификации).

## Пример 3

Использование API `ChatGTP-4` для вычленения брендов из названий продуктов.
Здесь будет похоже на пример с Яндекс.Метрикой, но отлчие в отсутствии слоя абстракции между сервисом и проектом.

### 3. Семантика

- **Зависимость сборки.**
Сборка проекта (в контейнере `Docker`) полностью независима от API `ChatGPT`.
Вся связь осуществляется на уровне HTTP запросов, настройки переменными окружения.

- **Зависимость в runtime.**
Работа всего проекта в ходе выполнения полностью зависит от сервиса `ChatGPT`.
В случае отключения или недоступности проект работать не может.

- **Зависимость функциональности.**
Теоретически, `ChatGPT` может быть заменен любой языковой моделью, однако для этого нужно описать
обертку для абстракции любого сервиса для взаимодействия через HTTP запросы, на текущий момент функционал
зависит от сервиса на уровне hard code'а.

### 3. Характеристики

Ключевые характеристики использования сервиса для вычленения брендов:

- Скорость обработки (названий продуктов в сек.).
- Точность (качество) получаемого результата.
- Ограничение (при наличии) на количество запросов.
Все характеристики будут зависеть от сервиса, теоретически при смене сервиса можно получить изменение по скорости или отсутствие потолка на количество запросов, а также иную точность определения бренда.
Также можно добавить, что важной характеристикой будет также возможность локального использования языковой модели.

### 3. Допустимые изменения

Любое изменение в API со стороны сервиса, вероятно, приведет к поломке (зависимость).
Так как переход на другой сервис потребует изменения кода, также зависим в целом от доступности сервиса.
Доступность сервиса также определяется его доступностью с различных серверов (например, сервис недоступен из российских серверов).

## Пример 4

Использование библиотеки `PyQt6` для реализации `GUI` под проекты с Машиной Тьюринга.

### 4. Семантика

- **Зависимость сборки.**
Сборка проект не зависит от библиотеки `PyQt6`, так как проект не компилируется и в целом используемые в проекте библиотеки не зависят друг от друга.

- **Зависимость в runtime.**
Проекты с `GUI` полностью опираются на функцию `PyQt6` в качестве инструмента для создания графического интерфейса. Любые ошибки во время runtime приведут к крашу программы, поэтому здесь наблюдается однозначная зависимость.

- **Зависимость функциональности.**
В `Python` достаточно много альтернатив для графических библиотек (например `Tkinter`). В проекте с RAM машиной, класс, отвечающий за создание `GUI` импортируется отдельно и используется в качестве атрибута основного класса приложения. Не могу сказать, что в моем проекте достаточно будет только замены конфигурационных файлов. Но с небольшим рефакторингом, будет возможно создать объект на основе другой `GUI` библиотеки и использовать уже его для отрисовки интерфейса. Таким образом, в данном случае мы практически не зависим от `PyQt6`.

### 4. Характеристики

Ключевые характеристики для GUI библиотеки это, наверное производительность, и ассортимент графических элементов, которые можно использовать в проекте.
В этом смысле мы полностью зависим от тех элементов, которые разработчик предоставляет в `QtDesigner`, а замена фреймворка даст отличный набор инструментов.
В плане производительность, мы также остаемся зависимы от того, как "под капотом реализована" `PyQt6` (по-видимому это по большей части питоновская обертка над С++ QT).

### 4. Допустимые изменения

По сравнению с, например, `PyQt5` произошли достаточно значимые изменения в API программы. Поэтому можно предположить, что API в следующей версии также может претерпеть изменения, что приведет к необходимости переписывать проект под новую версию. Здесь имеется однозначная зависимость от изменений в API разработчиков библиотеки.
Также внутри программ имеются некоторые ограничения, например:

- Проверка на deadlock введенной пользователем программы в реализации RAM машины (программа останавливается и выдает предупреждение пользователю).
- Ограничение на длину ленты в Машине Тьюринга. Для безопасности, программа не позволит расширять ленту до бесконечности (при достижении потолка программа остановится и выдаст пользователю окно с ошибкой).

## Выводы

- Разделение зависимостей на различные виды помогает думать о них в разном ключе. Мы можем выделять ключевые моменты - например, сборка проекта (вероятно всегда) крайне важна (семантика), но краш программы в специфических условиях (допустимые изменения) может быть исправлен впоследствии.
- Ключевое правило: **Свойство программы зависит от некоторого компонента только тогда, когда этот компонент -- фактическая причина свойства**. Это позволяет размышлять о зависимостях, не впадая в циклические размышления (`A` влияет на `B`, но `B` влияет на глобальное свойство, которое косвенно влияет на `A` и т.д.).
- Такой подход в целом позволяет не просто говорить, что `A` зависит от `B`, а решать разные проблемы более выборочно. Зависимости в целом неизбежны (нельзя ведь писать абсолютно все сервисы с нуля :)), но если, например,  независимость от конкретного сервиса важна для нас, то мы можем решать эту проблему (вверением дополнительного уровня абстракции) не затрагивая пока другие зависимости, что дает нам большую гибкость при работе с внешними библиотеками.
