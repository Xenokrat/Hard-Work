# Hard Work - Что такое баг

## 1. Это не баг

### 1.1 Пример

В первом проекте -- реализацией графического интерфейса для Машины Тьюринга, для реализации действия кнопки `stop` , она функционирует в отдельном треде.
При изучении советов, как действовать в такой ситуации, добавил мьютекс. Соответственно, во всем проекте, где происходит переключение между тредами, используется Мьютекс.
На самом деле в `PyQt6` вполне можно обойтись и без него, как я и сделал во втором проекте с `RAM` машиной.
Но удаление Мьютекса потребовало бы переработки значительного количества кода.

```python
def update_tape_graphics(self):
    with QMutexLocker(self.machine.mutex):
        scene = QGraphicsScene()
        ...
```

### 1.2 Пример

Для реализации бота для `Slack` используется библиотека `slack_bolt`.
В ней можно регистрировать команды, которые удобно запускать из чата, чтобы отслеживать состояние например БД или парсеров.
Проблема в том, что это реализовано при помощи декоратора, и в такие функции сложно передать внешние параметры.
А если какие-либо команды, используют например один и тот же запрос к БД, такой запрос придется делать заново в каждом отдельном случае, особенно неприятно это для тяжелых запросов, которые могут выполняться до минуты.
Скорее всего эту проблему можно решить, но пока все работает не совсем оптимально, но достаточно хорошо для пользования, вноситься изменения скорее всего не будут.

```python
@app.command("/check_parsers")
def parsers_command(ack, say, logger):
    # Acknowledge command request
    ack("Fetching data from DB")
    try:
        result = get_parsers_data()
        logger.info(result)
        say(result)
    except Exception as e:
        logger.error(e)
```

## 2. Это не баг (а что-то другое)

### 2.1 Пример

На работе в продовом коде имеется большое количество стилистически очень плохого кода, часто с 6-7 уровнями вложенности условий/циклов.
Как правило это что-то связанное с работой с внешней API (например с сервисами по работе с геоданными).
Приводить в норму такой код зачастую просто некому.

```python
for key, value in list_city.items():
    for localname in value['address']:
        if not id_osm:
            if localname['type'] == 'country' and localname['localname'] == country:
                for address in list_city[key]['address']:
                    if address['place_type'] == 'city' and address['osm_type'] == 'R':
                        id_osm = address['osm_id']
                    if not id_osm:
                        if address['place_type'] == 'town' and address['osm_type'] == 'R':
                            id_osm = address['osm_id']
```

### 2.2 Пример

Скрипт для формирования отчета для клиентов.
Запускается при помощи `config.yml` файла.
В файле можно указать какие именно отчеты требуются и также передать параметры для отчетов.
Однако в текущей версии все параметры являются только "глобальными", т.е. распространяются одинаково на все отчеты.

```yaml
date_range:
  - 2023-07-27
  - 2023-07-30
stages:
  - stage: Вставка Клиента
    tasks:
    - pepsi_insert_client1_retro
    - pepsi_insert_client2_retro
    - pepsi_insert_client3_retro
```

Имеется потребность при запуске индивидуально настраивать параметры отчетов, так чтобы например их конкретные параметры перезаписывали глобальные.

```yaml
date_range:
  - 2023-07-27
  - 2023-07-30
stages:
  - stage: Вставка Клиента
    tasks:
    - pepsi_insert_client1_retro:
     - date: [2023-08-01]
  - apps: [app1, app2]
```

На текущий момент это невозможно и требуется перезапускать скрипт с конфигами под каждый случай.
Все это является явными примером технического долга, когда есть потребность в внесении изменений, но на текущий момент удовлетворяется на "и так работает".

### 3. Это сбивает людей с толку

### 3.1 Пример

Внутри контейнера в `Docker` функция запрашивает таймстемпы по приложениям, которые приходят в локальном часовом поясе (Европа/Москва). Внутри контейнера `datetime.now()` возвращает время в `UTC`. В итоге вся конструкция, чтобы привести к одному поясу и посчитать разницу во времени в часах, выглядит следующим образом.

```python
upd_timestamp: datetime = data[1]
# turn to Europe/Moscow tz
time_now_local = datetime.now() + timedelta(hours=3)
upd_diff = (time_now_local - upd_timestamp).seconds // 3600  # to hours
```

### 3.2 Пример

Имелась работая система для мониторинга данных в БД, которая отправляла каждую минуту серию запросов к БД, проверяла ряд условий, затем, если такой алерт уже был недавно, откладывала его публикацию в рабочем чате.
Вся эта система была очень запутанной, так как:

1. Использовалось большое количество настроечных констант, так как под каждое условие имеется своя задержка.
2. Если одна и та же проблема повторялась, сообщение о ней "задерживалось" на все большее время.
3. Зато если проблемы не было некоторое время, когда она возвращалась, сообщения первое время просто "спамились" в чат.
В целом на уровне дизайна это было не очень, и стороннему человеку было трудно понять что происходит и внести корректировки в это.

```python
from alerts_parsers.config import (
    ALERT_TIME_INCREASE_MULTIPLIER,
    PLATFORMS,
    SEARCH_PLATFORMS,
    BANNER_PLATFORMS,
    UPD_ALERT_PERIOD_SECONDS,
    UPD_BANNER_ALERT_PERIOD_SECONDS,
    UPD_ALERT_TIME_INITIAL_DELAY,
)

...
for row in data:
    platform, db_time = row
    time_delta = abs((current_time - db_time).total_seconds())
    is_platform_not_in_list = platform not in self.platfrom_check_delay
    is_alert_triggered = time_delta > self.alert_trigger_time
    is_alert_triggered_not_delayed = (
        current_time > self.platfrom_check_delay[platform] and
        is_alert_triggered
    )
if any([
    is_platform_not_in_list,
    is_alert_triggered_not_delayed,
]):
```

Впоследствии перешли просто к более простой схеме, где мониторинги проверяются только несколько раз в день в установленное время.

### 4. Это хрупкость

### 4.1 Пример

Когда то сам такое сделал, не смог найти где :).
Имелась `Python` функция, которая возвращала либо `int` либо `None`.
Проверка на условие возвращения была записана следующим образом:

```python
def some_function(*args) -> int | None:
    ...

    if some_function(args):
        # do this
    else:
        # do something else
```

В данном случае, если функция вернет число, то сработает первое условие.
Если возвращается `None`, то сработает второе условие.
Но вообще, для `int` в `Python`, возвращение `0` тоже считается как `False`, поэтому мог бы быть случай, когда вернулось число, но обрабатывалось бы второе условие.
Условия, в которых работала функция никогда не возвращала ноль, но если бы условия изменились, возник бы баг.

### 4.2 Пример

В одной из первых версий реализации проекта по `Машине Тьюринга` и основной воркер приложения и интерфейс находились в одном классе.
Для небольшого приложения это в целом не проблема, но только до тех пор, пока не понадобится вносить большие изменения в пользовательский интерфейс.
Наиболее быстрым способом было бы сгенерировать измененный GUI при помощи `Qt дизайнера`. Однако он имеет тенденцию перезаписывать файл с интерфейсом :). Таким образом, можно случайно потерять всю внутреннюю логику работы программы.
Гораздо более правильным решением конечно же было использовать через композицию весь GUI, подключая его как атрибут основного класса программы.

```python
class RamMachine(QWidget):
    def __init__(self) -> None:
        super().__init__()
        ...
        self.ui = Ui_Form()
```

### 5. Не соответствует требованиям OSHA

### 5.1 Пример

В одном из ботов (для Slack) имелась функция, которая реагирует на `event` открытия главной страницы с ботом.
Функция впоследствии стала не нужна, так как не использовалась.
Чтобы не перенастраивать права бота и не переустанавливать его в рабочую среду, функцию оставили "пустой" (ничего не делает и не возвращает).
Если удалить ее (что для человека со стороны казалось бы правильно, так как это просто лишняя функция), то это вызывало ошибку со стороны `Slack`

### 5.2 Пример

В определенный момент времени, возникла потребность измерять время формирования отчетов.
Для этого в логировании выводилось время выполнения функции в секундах при помощи декоратора - это было значительно удобнее, чем самому вычислять по разнице времени между логами.

```python
@generic_logger("Execute query", "INFO")
    def execute_select_query(self, query: str) -> List[Tuple]:
        return self.client.execute(query, with_column_types=True)

def generic_logger(text: str, log_level: str = "INFO"):
    def decorator(func: FuncT) -> FuncT:
        @wraps(func)
        def wrapper(*args: Any, **kwargs: Any) -> Optional[Any]:
            log_with_level = getattr(log, log_level.lower())
            log_with_level(f"{text}")
            start = time.time()
            result = func(*args, **kwargs)
            end = time.time()
            log_with_level(
                f"{text}: {func.__name__} executed, time spent: {round(end - start)}"
            )
            return result
        return cast(FuncT, wrapper)
    return decorator
```

Впоследствии пришлось отказаться от использования его.
Проблема в том, что начали использовать асинхронные функции для выполнения запросов к БД ломаются, если их обернуть в этот декоратор.
Если кто-то попробует использовать этот декоратор на асинхронной функции, то это просто сломается в рантайме.

## Выводы

Если проанализировать все описанные случаи, значительную часть из них можно было бы избежать, если заранее знать, или хотя бы спрогнозировать, какие изменения могут возникнуть в системе в ближайшее время.
И многие примеры странных и хрупких решений - это также следствие необходимости сделать быстро хотя бы что-то рабочее, без оглядки на то, насколько решение гибкое или грамотное. Потому что адекватное решение стоит затрат прямо сейчас, а заплатки нет.
И третий источник таких ошибок - в моем случае наверное нехватка опыта. Но в целом мне кажется это полезное упражнения, т.к. это позволяет взглянуть на программу уже с холодной головой и понемногу начинать замечать эти источники (не-)багов заранее и обходить их прямо сейчас, вместо написания костылей потом.
