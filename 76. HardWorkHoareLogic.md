# Hard Work - Логика Хоара для программистов

## Пример 1

```python
# Спецификация: функция должна возвращать диапазон дат между указанными датами включительно
# Предусловие: {
#    - date1 является классом datetime или его потомком 
#    - date2 является классом datetime или его потомком 
# }
def get_daterange(date1: datetime, date2: datetime) -> List[datetime]:
    return [
        date1 + timedelta(days=x)
        for x in range((date2 - date1).days + 1)
    ]
# Постусловие: {
#    Возвращается: Лист объектов типа datetime с каждым днём между date1
#                  и date2 включительно 
# }
```

Данная функция используеся как правило на значениях дат,
которые получаются после парсинга конфига в .TOML формате.
Поэтому корректность значения даты обеспечивается парсером (`tomllib`)
С другой стороны, в конфиг можно вписать по ошибке значения другого типа,
и тогда это приведет к исключению.

## Пример 2

```python
# Спецификация: функция должна делить указанный диапазон дат на указанный набор частей
# Предусловие: {
#    - datelist: Лист объектов типа datetime 
#    - parts: положительное число больше 0
# }
def _date_list_split(
    datelist: List[datetime],
    parts: int
) -> List[List[datetime]]:
    return list(filter(lambda lst: len(lst) > 0,
                [datelist[i::parts] for i in range(parts)]))
# Постусловие: {
#    Возвращается: Список списков(!) объектов типа datetime разделяющий
#                  начальный диапазон дат datelist на parts частей
#                  Не создаёт пустых список (при len(datelist) > parts) 
# }
```

Данная функция используеся как правило вместе с предыдущей,
в таком случае мы можем сказать, что корректность datelist опеспечивается
её спецификацией.
Корректность `parts` никак не проверяется, не гарантируется, поэтому возможно
стоит добавить что-то вроде:

```python
    if not parts > 0:
        raise ValueError
```


## Пример 3

```python
# Спецификация: функция выполяет запрос на клиенте с указанными параметрами
# Предусловия: {
#   client - валидный клиент, с методов execute
#   query - валидный запрос типа str,
#   params - словарь типа строка | объект,
#   query содержит все перечисленные в params параметры 
# }
def client_execute(
    client: Client, query: str, params: dict[str, object]
) -> None | list[tuple[Any, ...]]:
    return client.execute(query, params)
# Постусловие: {
#   Возвращается результат выполнения запроса в формате Список кортежей объектов
#                или None, если запрос не предполагает возврата значений
# }
```

Корректность составленного запроса как бы является "внешней" по отношению к Питону,
поэтому возможно не должна относиться к предусловиям.
В остальном в данной функции внутри вообще не обеспечиваются никакие гарантии
при наружении указанных предусловий.

## Пример 4


```python
# Спецификация: функция валидирует строковое значение координат для атрибута доски класса
# Предусловия: {
#   str_coord - состоит из 2 стоковых значений цифр
# }
def _validate_coords(self, str_coord: str) -> bool:
    if len(str_coord) != 2:
        return False
    board_size = self._board.get_size()
    if int(str_coord[0]) - 1 < 0 or int(str_coord[0]) > board_size:
        return False
    if int(str_coord[1]) - 1 < 0 or int(str_coord[1]) > board_size:
        return False
    return True
# Постусловие: {
#   Возвращается результат проверки строковых координат на валидность
#                для объекта поля класса
# }
```

Функция проверяет некоторую часть предусловия, однако в отдельных случаях
приведёт к возникновению исключения (например, для `1A`).

## Пример 5

```ocaml
(* Спецификация - функция обеспечивает работу TCP сервера и неблокирующую обработку клиентов*)
(* Предусловия: {
   server_socket - объект типа file_descriptor, TCP-сокет, не закрыт
   количество тредов для Domain.swap не превышает максимальное для ОС
} *)
let rec server_loop server_socket () =
  try
    let client_socket, _ = accept server_socket in
    let handler =
      Domain.spawn (fun _ ->
          handle_client client_socket ();
          close client_socket)
    in
    let _ = Domain.join handler in
    server_loop server_socket ()
  with _ -> close server_socket
(* Постусловие: {
   Для нового клиента создан отдельный тред-обработчик
   при наличии ошибок сокер сервера корректно закрыт
} *)
```

OCaml обеспечивает корректную работу собственного кода благодаря мощной системе типов,
однако всё внешнее по отношению к нему, например как раз сокеты могут приводить
к исключительным ситуациям, например даже при обработке ошибок может произойти попытка
закрыть уже закрытый сокет.

## Выводы

Python как язык с динамической типизацией, поэтому практически все
наши описания предусловий/постуслови не гарантированы кодом и ошибки
выявляются только в рантайме.
Хотя фактически возможно проверять типы конструкциями вроде `type(x) == int`,
это приводит к быстрому "замусореванию" кода. Вероятно, нужно просто смириться
с тем, что это особенность динамически типизированных языков -- отсутствие "стабильных гарантий",
подстраховывающих программиста и использовать внешние инструменты, вроде линтеров.
Ещё момент, который мне не полностью ясен - верно ли, что проверка нарушения предусловий не входит 
в ответственность функции, где они были нарушены (иначе писать на Python было бы
практически невозможно :))? 
В этом ключе интересно сравнить Python с OCaml, где выполнение программы в рантайме
фактически гарантируется системой типов и компилятором, поэтому рассуждать там
о правильности программы гораздо проще, однако за это приходится расплачиваться скоростью/сложностью
написания кода.

