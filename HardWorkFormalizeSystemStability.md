# Hard Work - Формализуем понятие надёжности системы

## Система - программа для планового управления процессами в БД

### Свойство 1

В БД имеются 3 ноды, которые могут выполнять запросы независимо.
Ноды нужно создать с оптимальным количеством ресурсов (требует время).
Т.е. свойство - количество готовых к работе нод с заданными ресурсами.

#### Широкий диапазон 1

Нижняя граница - Поднята и готова к работе хотя бы одна нода.
(Т.е. мы можем начинать запускать работу на стороне базы.)
Верхняя граница - Подняты и готовы к работе все ноды.

#### Узкий диапазон 1

Подняты и готовы к работе все ноды.
Верхняя/нижняя границы - Подняты и готовы к работе все ноды.

#### Инвариант 1

Здесь я думаю для этого свойства будет **STABLE**, так как при выходе из строя ноды ее можно восстановить за ограниченное время, и поэтому также можно добавить сюда и **RESILIENT**.
(здесь предусловие **STABLE** (широкий диапазон) => **RESILIENT** как бы уже соблюдается, в целом можно сказать, что дальшейшее ослабление свойств не обязательно)

**Характеристика скорости восстановления.**
Можно оценить, что если скорость поднятия нод примерно час и работа, которую они должны выполнить, должна быть завершена в течении суток, то можно сказать, что
по **RESILIENT** мы скорее всего не нуждаемся в строгих временных ограничениях.

### Свойство 2

Объем RAM, который выделен под обработку запросов.
Характеристика, насколько эффективно мы используем выделенные ресурсы в ходе работы.

#### Широкий диапазон 2

Нижняя граница (3 x 12Гб)
Верхняя граница - (3 x 120Гб)

#### Узкий диапазон 2

Нижняя граница (3 x 60Гб)
Верхняя граница - (3 x 120Гб)

#### Инвариант 2

Здесь если я правильно понимаю, рассуждение следующее: если по какой-то причиные мы выходим за верхний диапазон, то это приводит к крашу программы,
при этом даже при попадании в рабочий диапазон мы не можем полностью "управлять" этим, поэтому разумно сказать, что это **STRONG** свойство.
Т.е. оно **STRONG** в широком диапазоне (а следовательно и в узком).

К **TRIPWIRE** мы не можем стремиться, так как на 100% не управляем поступающим для обработки объемом данных.
Идеально получается было бы предусловие **STABLE** (широкий диапазон) => **RESILIENT** (узкий), чтобы мы могли не падать при выходе широкие границы (например делить поток данных на меньшие чанки) и перезапускать процесс при выходе из узкого.

### Свойство 3

Скорость обновления дашборда при использовании в BI системе.

#### Широкий диапазон 3

Все это сложно оценить объективно, но примено на личном опыте до появления подозрений, что то-то не работает:

0-60 сек.

#### Узкий диапазон 3

В целом, чтобы клиент не испытывал раздражения при обновлении изображения, приемлимая скорость навскидку:

0-2 сек.

#### Инвариант 3

**STABLE** в широком диапазоне, т.к. по достижению приемлимого времени обновления даже при привышении это не приведет к катастрофе.
=> **RESILIENT** (задать как предусловие) в узком диапазоне, т.е. при общей стабильности в широком диапазоне мы должны достичь возможности восстановить 2 секундный интервал для удобства пользователя.

### Свойство 4

Количество RAM которое использует один инстанс запущенного в `Docker` приложения на сервере.

#### Широкий диапазон 4

На сервере с 128 Гб RAM может быть около 20 контейнеров с программой.
В широком диапазоне объем памяти на контейнер может быть в пределах

512 Мб - 6 Гб

Больше может привести к падению сервера, в этом случае он не может восстановиться сам по себе.

#### Узкий диапазон 4

Оптимально я бы сказал, что разумный диапазон, который оставляет 
возможность для добавления новых контейнеров при необходимости и запаса прочности:

512 Мб - 3 Гб

#### Инвариант 4

В нашем случае при падении сервера он не может восстановиться сам (т.е. в широком диапазоне мы не можем сказать, что система **RESILIENT** (с другой стороны при вмешательстве человека, ее можно восстановить в разумные сроки)). В то же время превышение по количеству памяти может как раз легко привести к такому сценарию.
Поэтому в широком диапазоне считаем систему **STRONG**.
В узком диапазоне отклонения допустимы и есть возможности приведения системы обратно к этому диапазону (**STABLE** + **RESILIENT**).

В идеале, для нормальной работы системы, без необходимости вмешательства для перезапуска сервера, нужно устанавливать следующий сценарий:

**STABLE**(широкий диапазон) => **RESILIENT (STABLE)**(узкий диапазон).

Добиться этого можно, вероятно, введя механизм, который бы например "убивал" менее приоритетные контейнеры при приближении к вехней отметке по RAM.

### Свойство 5

Время, которое парсер тратит на парсинг одного магазина в приложении (лучше выразить через количество раз в сутки, когда парсер прошелся по магазинам внутри приложения).

#### Широкий диапазон 5

Проход парсера по всем приложениям хотя бы один раз (в реальности по тем или иным причинам на самом деле - хотя бы на 90%) | или лучше.
(90% - $+\infin$)

#### Узкий диапазон 5

Проход парсера по всем приложениям хотя бы 2 раза (200%) | или лучше.
(200% - $+\infin$)

#### Инвариант 5

- широкий диапазон: не можем позволить себе нарушать границы по широкому диапазону, т.к. эту информацию при потере уже не восстановить, поэтому скажем что **STRONG**
- узкий диапазон: можно допустить колебания, т.к. когда получена хотя бы одна запись на магазин, это дает уже 90% всей необходимой информации, поэтому **STABLE**.
- в обоих случаях эти свойства не устойчивы, т.е. не могу быть "восстановлены" в допустимом виде.

В идеале нужно стремиться к **STRONG** т.к. это дает 100% нужной информации для конечного потребителя, но это конечно не оставляет пространства для маневра.

## Выводы

Полезное занятие хотя бы потому, что ранее я никогда не встречал попыток как-то формально выразить / обосновать хоть как-то устойчивость системы, в реальной работе все предпочитают делать это "на глаз".

Тут стоит отметить, что я возможно не на 100% понял подход, предлагаемый в занятии, и, возможно, постараюсь выделить время почитать этот учебник `learntla`.

Мое понимание следующее:

- мы прикидываем инвариант в узком и широком диапазоне характеристики.
- предусловие значит, что мы задаем зависимость между инвариантов в широком диапазоне и в узком диапазоне (если X инвариант гарантирован в широком диапазоне, следовательно требуетм, чтобы Y инвариант был соблюден в узком).
- своство системы может быть одним из: **STRONG** | **TRIPWIRE** | **STABLE** | **WEAK** + отдельно может быть или не быть ***RESILIENT** в том или ином диапазоне.
- то, к чему следует стремиться:
  - с точки зрения того, кто поддерживает собственно работу системы мы хотим быть как можно ближе к **WEAK**, потому что это значит, что система очень гибкая и считается "рабочей" при большом диапазоне состояний.
  - с точки зрения "потребителя" естественно, что **STRONG** обеспечивает идеальное соблюдение всех требований.
  - задача в итоге для нас, как разработчика системы - найти баланс между этмими 2 противоположными состояниями.
  - тут мне видится следующий пример: в видеоиграх при большой нагрузке допускаются просадки по частоте кадров. Если бы инвариант был бы **STRONG** это приводило бы к немедленному крашу при отклонении, однако системе дается "гибкость" в виде снижения FPS. Но если бы FPS можно было бы менять неограниченно, это привело бы к неудобству пользователя, т.е. **WEAK** явно не подходящее состояние для конечного продукта. Всегда нужно искать средний вариант, задавая допустимый набор состояний.
