# Hard Work - Задачка N 0

## 1. Как работает код и краткое описание. 

```py
def fibs_sum():             # Данная функция создаёт генератор
    fsum = 0                # Вначале при первом проходе генератора fsum = 0
    while True:             # Бесконечный цикл, который позволяет генератору отдавать числа последовательности Фибоначчи
        fsum += yield fsum  # ВАЖНЫЙ момент: генератор сначала отдаёт значение fsum, затем останавливается перед операцией `+=`
                            # Когда работа генератора возобновиться при следующей передаче в него gsum.send(b),
                            # значение b заменит выражение (yield fsum) и получится fsum += b, затем в следующем цикле while 
                            # Оно снова остановится, отдав fsum из yield (увеличенный на b, как указано выше)
     
def get_fibs(num):          # Данная функция также будет генератором, так как для возврата значений использует yield
    a, b = 0, 1             # Задаются начальные значения последовательности
    gsum = fibs_sum()       # Создаётся генератор из fibs_sum

    gsum.send(None)         # send(None) - необхдимое действие для запуска генератора fibs_sum,
                            # оно выше прогоняет тело функции до первого yield
    for i in range(num):    
        yield gsum.send(b)  # Здесь в цикле генератор одновременно передаёт в fibs_sum значение b и воващает из него yield значение 
        c = b               # Эта секция для реализации последовательности Фибоначчи: 
        b = a + b           #     b - переменная содержит значения последовательности, a - переменная для сохранения значения перед b
        a = c               #     чтобы получить следущее значение последовательности, нужно прибавить b = b + a, а предущее значение станет теперь b
                            #     с - используется как временная переменная для обмена значениями
```

## 2. Найти ошибку и исправить

При запуске кода получится следующий результат

```py
print(list(get_fibs(5)))
# -> [0, 1, 2, 4, 7, 12] полученная последовательность
# -> [0, 1, 1, 2, 3, 5] правильная последовательность
```

Попробуем разобраться почему так, рассмотрев как изменяются переменные на каждом этапе

| i   | fibs_sum  |  get_fibs    |
|:---:|:---------:|:------------:|
| None|  fsum = 0 | b = 1, a = 0 |
| 0   |  fsum = 1 | b = 1, a = 1 |
| 1   |  fsum = 2 | b = 2, a = 1 |
| 2   |  fsum = 4 | b = 3, a = 2 |
| 3   |  fsum = 7 | b = 5, a = 3 |

Видим, что `b` увеличивается в соответствии с правильной последовательностью Фибоначчи.
В то же время на каждом этапе `fsum` увеличивается на значение `b`.
Т.е. `fsum` на каждом этапе растет не на предыдущее значение (т.е. `a`), а растёт
как сумма последовательности Фибоначчи (заметим, что по смыслу названия функции
`fibs_sum` как раз таки отражает то, что она считает сумму элементов последовательности
на каждом этапе :)).

### Как исправить?

Есть несколько вариантов:

Самый простой, в `fibs_sum` достаточно не увеличивать переменную `fsum`, а просто возвращать
её значение.

```py
def fibs_sum():           
    fsum = 0              
    while True:           
        fsum = yield fsum
#           ^
#           |
```

Однако в целом, можно заметить, что раз `fibs_sum` считает сумму последовательности.
Можно обойтись полностью без этой функции:

```py
def get_fibs(num):
    a, b = 0, 1
    gsum = fibs_sum()

    for i in range(num):
        yield b
        b, a = a + b, b
```

## Выводы

Вообще, до этого занятия думал, что немного понимаю генераторы в Python. Но метод `send` сбил меня с толку, т.к. я понятия не имел, что пользователь генератора может управлять его поведением
"снаружи", изменяя значение выражения `yield`. Это в целом очень мощный инструмент, который используется, например, для реализации корутин.
В то же время легко заменить, как непросто воспринимать изменения переменных и в целом динамику
между генератором и его "пользователем", что может легко привести к трудноотлавливаемым ошибкам в коде.
