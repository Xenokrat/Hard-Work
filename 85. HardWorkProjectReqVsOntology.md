# Hard Work - Проектные требования или проектная онтология? 

## Пример 1

Учебный проект "Игра три-в-ряд"

### 1.1 Онтология, ориентированная на требования

Этот проект был специально, чтобы тренироваться в разработке ООП дизайна программ, поэтому
как полагается последовательно выделяли:

- Из каких элементов состоит игра (Поле, элемент игрового поля, пользовательский UI)
- Какие алгоритмы нужны (обработка логики игры, событий)
- Как элементы выше должны координироваться и взаимодействовать друг с другом.

Проблемы на этом уровне начались с последнего уровня, так как выделить изолированно объекты - какие данные они используют и их методы не так сложно,
гораздо сложнее потом понять, как они должны взаимодействовать.
После этого я фактически "соскочил" с онтологического уровня полностью к методу проб-ошибок.

### 1.2 Идентификация поломок

На этом этапе стало ясно, что мой практический уровень "реальных требований" не очень ладит с онтологическим :).

Этот этап начался с отладки структуры архитектурного уровня, потому что быстро стало понятно что 
игровая логика должна работать не совсем так как я представлял в голове 
(теперь понимаю, почему фреймворки для графики используют обычно что-то вроде реактивного программирования).

Кроме того, после отлаживал другие требования:
- Если элементы игрового поля отличаются только символами, то их визуально тяжело различить.
- Также визуально сложно различить движение элементов поля при смещении.
- Сгенерированные "новые" элементы поля, приходящие сверху не должны иметь "готовых" комбинаций.

Все эти вещи были кое-как налажены, однако не покидает сомнение, что лучшая архитектура сильно бы упростила этот этап.

## Пример 2

Проект бота для мессенджера для оперативной сводки по данным

### 1.1 Онтология, ориентированная на требования

Взаимодействие пользователя с ботом - при помощи встроенного в `Slack` понятия slack-команды.
Наша собственная обёртка вокруг этого - `User Command` для реализации нашей логики.

Интерфейс для взаимодействия с БД - так как запросы аналитического характера (читай, большие и сложные, и только на чтение), то ORM не используем,
вместо этого RAW SQL, запросы храним прямо в репозитории как код.
Чтобы не делать полноценный Backend, просто использовался Web-hook через сокет (хотя его упорно продолжают называть бэком).
Здесь, за счёт простоты проекта уровень дизайна в основном оказался правильным изначально (кроме того, что часть кода была
переписана в ФП-стиле, об этом чуть ниже).

### 2.2 Идентификация поломок

Естественно, пользователи бота хотели бы предложить дополнительные функции, это было довольно предсказуемо.
Но на практике я понял быстро, что мой собственный ООП дизайн был совсем не очень (это было ещё до всех курсов по ООП) хорошо работал.
К счастью, получилось быстро перевести логику к чему-то близкому к функциональному программированию:
функции достают пользователю нужные данные, а затем обрабатываются и форматируются через серию чистых функций до конечного результата. Это оказалось
гораздо проще, потому что в такой системе не особо много "объектов", зато много движения данных, причём достаточно понятного.
Гибкость системы обеспечивается просто за счёт подстановки функций с нужным интерфейсом (например для `Formatter`, одна функция выводит результат списком, а другая рисует `markdown` таблицу).

Сейчас не хватает чего-то вроде прозрачности использования разными людьми: если один человек запросил сложный запрос, а второму затем нужен точно такой же, то можно было бы как-то
прозрачно сообщить всем пользователям бота о том, что "сейчас формируются такие-то данные". 
Это будет следующей точкой для изменения.

Требования тут появляются неожиданно и "на лету".

## Пример 3

Проект Фреймворк для сборки аналитических отчётов из данных

### 3.1 Онтология, ориентированная на требования

Также определил основные понятия:

- Задача            (единица работы, единственное обращение в БД, единственная отправка уведомлений и т.д.)
- Группа задач      (по смыслу не сколько общая тема задач, скорее задачи которые допустимо запускать параллельно).
- Поток задач       (последовательность групп задач, учитывающая зависимости)
- Зависимость задач (список задач, которые должны быть предварительно выполнены перед запуском данной)
- Ресурс            (числовое выражение (просто `int`) примерного объем некоего "ресурса", который зависит от исполнителя задачи)

Хорошо было использовать знания из курса ООАП-3. Единственное, что ещё понял для себя: лучше оставлять классы-проектирования
прям на самый последний момент. Изначально не стоит зацикливаться на том, как объекты должны взаимодействовать, лучше определить
чем они являются.

### 3.2 Идентификация поломок

Опять же, при реализации быстро начали вскрываться "поломки", связанные с архитектурным уровнем:

- Можно, например, абстрагировать "исполнителя задач", однако в какой-то момент оказывается, что понятие Ресурса
плохо применимо ко всем исполнителям кроме одного, для других пришлось использовать костыль вроде "Нулевого ресурса".
- Зависимостями тяжело управлять на уровне групп задач, так как каждая задача может иметь зависимости.
- Здесь, наоборот (от п.2) пришёл к идее что ООП отлично подходит для абстрагирования "задач", "исполнителей", "алгоритма
разрешения зависимостей" и т.д. Очевидно, что задачи будут добавляться новые, интерфейс для их добавления как раз относительно
несложно предсказать (по крайней мере я сейчас так думаю :)).
- Когда задачи падают с ошибкой при параллельном выполнении, это непросто обработать, и нужно возвращаться к планированию, как
поступать в таких ситуациях.

## Пример 4

Проект "Реализация простой shell-программы"

### 4.1 Онтология, ориентированная на требования

Постарался выделить и определить основные понятия:

- Интерфейс ввода
- REPL - цикл жизни
- Build-in команды
- Токенизатор
- Перенаправления потоков (stdtin/stdout/stderr)

### 4.2 Идентификация поломок

Проект начал писать на `Go` и пока не знаю как делать многие вещи "идиоматически":
- Например, изначально все комманды были в одном большом `switch-case`, быстро стало неудобно делать что-то,
когда одна команда должна знать о существовании других (например команда `type`).
- Из-за неудобств выше практически каждый новый шаг (из описанных выше) приводил к тому, что на 70% переписывался прошлый.

## Выводы

Возможно это говорит моя неопытность как проектировщика, но на данный момент
суммарно итеративная разработка (как было сказано, "от проектирования к опыту и обратно") гораздо ближе мне
и с точки зрения реальной жизни, где большинство прогнозов относительно того, что может меняться в программе, как правило, непредсказуемы,
и с точки зрения моей эффективности - от ошибок двигаться к соответствию проще и быстрее, чем корректно улавливать "суть" с чистого листа.

Кажется, что способность онтологически задавать устройство проекта приходит только с опытом,
потому что о многих вещах просто невозможно узнать, даже "сильно подумав", можно только сделать реализацию,
посмотреть как она (не-)работает, и затем понять и прочувствовать "почему так".
