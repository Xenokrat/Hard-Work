# Hard Work - Избавляемся от зависимости от зависимостей 3

## 1. Зависимость фреймворка

Возьмем в качестве примера библиотеку драйвер подключения к `PostgreSQL` -- `psycopg2` `psycopg2` выполняет запросы к БД `PostgreSQL` и при необходимости возвращает данные.
Зависит ли он от поведения БД?

- Очевидно, что при различных неполадках (некорректный запрос, слишком тяжелый запрос, потеря соединения и т.д.). Библиотека в этих случаях не может отработать корректно (например, большой запрос будет бесконечно *висеть*.
- Является ли `psycopg2` фактической причиной всех этих потенциальных проблем? Очевидно, что не является.
- Будет ли проблема, связанная с багом (например, были проблемы с подключением через `SSL`) в библиотеке означать зависимость от фреймворка? Да, будет, так как неполадка является фактической причиной некорректной работы библиотеки.
Итог:
- Только свойства, связанные с корректной работой библиотеки будут означать зависимость (в этом случае открываем ждем фиксов или пытаемся скорректировать сами).
- Все свойства, связанные с качеством запросов и т.д. не должны рассматриваться в рамках зависимости от `psycopg2`.

## 2. Зависимость расшаренного формата

Можно привести пример из реализации GUI RAM-машины:

- Мы храним команды программы для RAM машины в формате `JSON`
- Пользователь может загрузить эти данные, превратив их в набор команд RAM-машины
- Пользователь также может сохранить набор команд в RAM-машине в `JSON` файл.

Эти 2 формата хранения команд изоморфны друг другу (надеюсь, правильно понял этот момент :)), потому что:

`
json-format-data == save(load(json-format-data))
ram-machine-data == load(save(ram-machine-data))
`

Также дополнительно можно сказать, что эти 2 формата не зависят друг от друга, но вместо этого зависят оба через условную договоренность о том, что правильно считать корректной программой для RAM-машины.

## 3. Зависимость зависимости

Имеем в сервисе мониторинга данных в БД переменную, которая определяет имеющийся в данный момент набор площадок (имеются в виду набор площадок сервисов доставки продуктов и статистика по нему в БД) -- `PLATFORMS`.
Эта переменная определяется в runtime'е и она же используется для обработки различных метрик, например:

- Записываем в `PLATFORMS` все доступные площадки за последние 2 недели.
- Сравнивая со списком площадок за вчера, понимаем что площадка 'выпала' и не обрабатывается.
- Создаем сообщение с алертом.

Таким образом `PLATFORMS` как определяется в процессе выполнения данными в БД, так и определяет результат работы программы.
Здесь могут возникать разного рода проблемы: например мы добавили тестовую площадку и получили в БД немного данных по ней. Теперь она будет определяться в `PLATFORMS` и создавать ложные алерты.
Причиной такой зависимости будет являться спецификация, которая определяет как получается список `PLATFORMS`. Изменить ситуацию мы можем, скорректировав спецификацию таким образом, чтобы `PLATFORMS` например определялась статично из настроечного файла.

## 4. Зависимость краша

Рассмотрим программу для создания клиентских отчетов.
Она включает в себя настроечный `yaml` файл, в котором будут записаны как названия отчета, так и (опционально) некоторые дополнительные параметры для составления отчета (например, требуемые для отчета даты, площадки, города и т.д.).
В некоторых случаях пользователь может указать такие некорректные параметры, которые могут привести к полному крашу программы (например, передать какие-либо спецсимволы в названии города).
В этом случае у нас есть 2 пути:

- На уровне суперспецификации запретить пользователю указывать некорректные параметры в настроечном файле (тогда зависимости нет).
- Включить в программе всевозможные проверки на корректность формата, в этом случае зависимость будет прослеживаться явно.

На практике лучше использовать второй вариант, чтобы на полагаться на человеческий фактор.

## 5. Зависимость перебрасывания

Ранее описывал схему работы парсеров в нашей компании, где реализуется типичная схема *подстраховки* для прокси подключения.
Если было предпринято несколько неудачных попыток, программа парсера будет пытаться использовать следующих доступный прокси в списке.
Первый раз я пришел к выводу, что в этом случае зависимость не имеет места, так как наличие *альтернативы* подразумевает выбор, а при наличии выбора в системе зависимость как бы снижается.
Но что если все прокси будут давать ошибку при подключении? Или все прокси будут уже заняты?
Очевидно (в соответствии с тексом занятия), что в этот случае зависимость будет не точечной, но вместо этого "размазанной" по множеству доступных прокси:

`{ proxy1, proxy2, proxy3, ... }`

В таком случае можно сделать вывод, что система зависит уже не от какого-то прокси, но вместо этого от имеющегося в наличии множества доступных прокси (фактическая причина невозможности работы парсера -- неспособность множества прокси обеспечить соединение). При наличии большого "запаса" думаю можно условиться, что мы справились с подобной зависимостью.

## 6. Зависимость инверсии

В Python программе по составлению аналитических отчетов на основе данных в БД имеем *абстрактный* класс `Task` который означает как раз один такой отчет.
Далее от такого класса наследуются уже конкретные реализации отчетов конкретного типа под конкретного клиента:

- `Client1DailyReportTask`
- `Client2WeeklyReportTask`
- и т.д.

Передавая такие классы для обработки другими классами (вроде `Processor`) используем аннотации типов:

```python
class Processor:
	def __init__(self, task: Task) -> None
		...
```

Аннотация типов позволяет видеть разработчику, класс какого типа должен использоваться здесь.
Далее, используем тайп-чекер `mypy`, который на основе аннотаций типов проверяет корректность кода.
Как раз, в случае, если мы устраняем все предупреждения `mypy`, считаем, что мы полностью контролируем зависимость на этом уровне.

## 7. Зависимость зацикливания

Имеем следующий пример:
Чат-бот для `Slack` (библиотека `slack-bolt`) использует для принятия сообщений эндпоинт на `FastAPI` бекэнде.
Отправка сообщения с целью выполнения ботом каких-либо действий зависит от `slack-bolt`. Корректная работа `slack-bolt` зависит от бекэнда, т.е. `FastAPI`.
Если мы принимаем, что зависимость не транзитивна, то тогда получается, что например запрос на формирование email через бота не зависит от `FastAPI`, хотя естественно при сбое работы фреймворка, результат получен не будет.
В этом случае, при возникновении неполадки нужно принять просто, что в конкретный момент мы решаем именно проблему зависимости `slack-bolt` от `FastAPI`, так как сбой первого фактически вызван вторым.

## 8. Зависимость высшего порядка

Имеем библиотеку для подключения к БД `Clickhouse`.
БД находится на сервисе Яндекса, и для корректного подключения требует SSL сертификат.
Есть несколько способов добиться того, чтобы сертификат использовался при создании подключения, обычно мы используем строковый путь до сертификата. В этих случаях могут возникать проблемы, связанные с использованием программы в контейнере `Docker`, так как путь в этом случае может отличаться (что зависит от того, как был собран контейнер).
С полученными новыми знаниями мы можем теперь сделать следующие выводы с зависимостью:

- Корректность подключения не зависит от того, как в программе в итоге реализована передача сертификата. Соответственно, на деле мы не имеем зависимость здесь - реализация подключения библиотекой -- не фактическая причина сбоя подключения.
- Однако работа программы в рантайме будет зависеть от способа передачи сертификата, и фактическая причина сбоев здесь уже будет заключаться в этом способе.

Как один из способов решения такой зависимости будет являться установка сертификата непосредственно на сервере.

## 9. Зависимость большинства

Недавно предпринимали попытки контролировать расход ресурсов на БД (мы используем облачное решение), для этого непосредственно перед запуском большого количества сложных запросов (например, ежедневные отчеты для клиентов), через `API` посылаем сигнал временно увеличить ресурсы на БД.
Однако, выход БД на новый уровень по ресурсам довольно продолжительное и нестабильное явление.
Есть несколько метрик, к которым можно обратиться, чтобы понять, увеличились уже ресурсы или нет -- обращение к `API`, 2 разных обращения к системным таблицам уже в самой БД.
Так как ни один вариант не 100% точный, приходится убеждаться что ресурсы увеличены по всем доступным метрикам.
Тут как раз очень похожий случай с *зависимостью перебрасывания* -- зависимость здесь прослеживается не до конкретного инструмента измерения ресурсов БД, но вместо этого "размазывается" по множеству доступных инструментов.
Таким образом, дальнейший запуск программы зависит от множества:

`{ metric1, metric2, metri3, ... }`

## Общие выводы

Изученный материал позволил мне лучше понимать природу зависимостей и рассуждать о них.
Правило **зависимость некоторого свойства от объекта имеет место только тогда, когда этот объект является фактической причиной данного свойства** имеет, на мой взгляд 2 ключевых момента:

- Во-первых, рассуждать нужно всегда о зависимости конкретного свойства, вместо элементов в системе.
- Во-вторых, **фактическая причина** -- это очень важный момент, который позволяет как бы изолировать наши рассуждения о той или иной зависимости, вместо того, чтобы затрагивать в рассуждении вообще все связанные элементы (в таких случаях всегда можно дойти до того, что "все зависит от всего").

Еще значимым для меня открытием было для меня **нетранзитивность** зависимостей. Этот принцип хорошо сочетается с фактической причиной и позволяет более-менее четко определять суть зависимости и принимать корректное решение.
