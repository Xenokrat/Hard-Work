# Hard Work -  О циклах по умному

## Пример 1

Имеем простой код из решения задачи по поиске наиболее часто встречающегося элемента в массиве.
Простое решение на `Python` подразумевает использование словаря и подсчёт в нем количества раз
сколько встречается там конкретный элемент.

`defaultdict` делает код немного компактнее, но в целом нам нужно пройтись циклами:

- по изначальному массиву
- по полученному словарю, чтобы выбрать самый часто встречающийся элемент.

```py
def majority_element(self, nums: List[int]) -> int:
    n = len(nums)
    m = defaultdict(int)
    
    for num in nums:
        m[num] += 1
    
    n = float('-inf')
    res = 0
    for key, value in m.items():
        if value > n:
            res = key
    
    return res
```

Функциональные языки вроде `Elixir` позволяют написать схожий по логике код
в гораздо более декларативном стиле, при этом не используя никаких явных циклов:

Мы применяем на коллекцию метод `frequencies`, и полученный map фильтруем по максимальному значению.
Далее остаётся только из пары "элемент-количество раз" выбрать элемент.

```ex
def majority_element(nums) do
    Enum.frequencies(nums) 
    |> Enum.max_by(&elem(&1, 1)) 
    |> elem(0)
end
```

## Пример 2

Возможность в `Python` при необходимости сократить количество цилклов до одного (т.е.
избавиться от всех вложенных циклов) обеспечивает функция `product` из стандартной библиотеки
`itertools`.

Допустим, нам нужно создать партиции для нескольких таблиц по датам для нескольких менеджеров,
вместо того, чтобы перебирать все варианты через 3 цикла `for`, мы можем сократить их до одного
(при этом мы итерируемся по объекту, который возвращает нам `product`, что обеспечивает дополнительную безопасность).

```py
TABLE_LIST = ['sales', 'stocks', 'prices']
DATES      = ['2024-01-01', '2024-01-02', '2024-01-03']
MANAGERS   = ['Tanya', 'Oleg']

def create_partition(date, table, manager) -> None: 
    ...

for date, table, manager in itertools.product(DATES, TABLES_LIST, MANAGERS):
    create_partition(date, table, manager) 
```

## Пример 3

Один из красивых способов представления "Игры жизни", который я видел,
не использует никаких классов для представления доски или клеток и также практически
не применяет циклов для расчета каждого этапа изменения "жизни" клеток на доске, вместо этого:

- используется генератор для представления всех соседних клеток текущей
- расчет распространения клеток каждй ход расчитывается сочетанием функций
`chain` из `itertools` и `map` для применения указанного выше генератора к текущим клеткам.
- используем списковые включения для итоговой фильтрации (аналогично примерению `filter()`).


```python
def neighbors(point):
    x, y = point
    yield x + 1, y
    yield x - 1, y
    yield x    , y + 1
    yield x    , y - 1
    yield x + 1, y + 1
    yield x + 1, y - 1
    yield x - 1, y + 1
    yield x - 1, y - 1

def filter_cond(point, board):
    count = sum((neigh in board) for neigh in neighbors(point))
    return count == 3 or (count == 2 and point in board)

def advance(board):
    newstate = set()
    recalc = board | set(itertools.chain(*map(neighbors, board)))
    return [point for point in recalc if filter_cond(point, board)] 

# Пример работы
glider = set([(0, 0), (1, 0), (2, 0), (0, 1), (1, 2)])
for i in range(1000):
    glider = advance(glider)
print(glider)
```

## Пример 4

Еще одно решение на `Elixir`, для случая когда нам нужно быстро обрезать строку от пробельных
символов и получить длину последнего слова (несмотря на то, что это похоже на одну из
`leetcode` задач, это на самом деле находит применение при парсинге названий продуктов и их
объемов, которые указываются в конце названия).

И снова мы можем использовать `pipe` оператор для того, чтобы очень ясно выразить логику

```ex
@spec length_of_last_word(s :: String.t) :: integer
def length_of_last_word(s) do
    if s == "", do: 0, else: s |> String.split |> List.last |> String.length
end
```

Снова, по сравнению с решением, которое не использует возможности манипуляции с строками:

```py
def length_of_last_word(self, s: str) -> int:
    r = len(s) - 1
    space_symbols = {' ', '\t', '\n'}

    # избавляется от пробелов в конце
    while r >= 0 and s[r] in space_symbols:
        r -= 1

    counter = 0
    while r >= 0 and s[r] in space_symbols:
        r -= 1
        counter += 1
    return counter
```

Нам не нужно беспокоится о выходе указателя `r` за пределы массива (или в случае Python можно получить неприятный баг, если в ходе цикла индекс станет отрицательным, и начет указывать на конец коллекции).

## Пример 5

Пример, как можно использовать `foldl` (или `reduce`) для поиска самого длинного
общего префикса в массиве строк.
В `Elixir` мы можем написать функцию, которая будет находить общий префикс для 2 строк, и затем
передать эту функцию в `reduce`, чтобы результат ее работы применяся далее в этой же функции,
только уже с следующей строкой, пока лист с строками не закончится.

```ex
@spec longest_common_prefix(strs :: [String.t]) :: String.t
def longest_common_prefix(strs) do
    common_str(strs)
end

defp common_str( [] ), do: ""
defp common_str(strs), do: Enum.reduce(strs, &common_str/2)
defp common_str(str1, str2), do: common_str(str1, str2, "")
defp common_str(<<x::utf8, xs::binary>>, <<x::utf8, ys::binary>>, res), 
    do: common_str(xs, ys, <<res::binary, x::utf8>>)
defp common_str(       _,        _, res), do: res
```

## Выводы

Уже какое-то время пришел к выводу, что нужно приучать себя изучать функциональные возможности языка, и различные инструменты итерации коллекций,
так как они обладают рядом преимуществ:

- Они практически исключают возможность ошибки выхода за пределы массива.
- Они очень выразительны, и часто дают возможность напрямую "читать" то что делает конкретный
участок кода, вместо того, чтобы представлять в голове, что происходит внутри цикла.

Но также в случае с `Python`, я понял, что не стоит также увлекаться слишком сильно идееё избавления от циклов, так как слишком большое нагромождение списковых включений и инструмента `map` дает такой же ничитабельнй код :). Тут стоит обращать внимание на то, как другие функциональные языки решают такие проблемы, например, вводя `pipe` оператор (|>).


