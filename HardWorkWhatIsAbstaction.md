# Hard Work - Что такое абстракция: разминочное

## Одинаковая реализация, но разная спецификация

### Пример 1

Если в какой либо обработке отчетов с использованием данных из БД мы используем 2 типа баз:

- PostgreSQL
- Clickhouse

То кажется разумным в целом создать отдельный абстрактный класс, который бы представлял собой обобщенное представление, что-то вроде:

```python
class AbstractDataBase(ABC):
    @abstractmethod
    def execute_read_query(self):
        ...
```

Такое в целом будет работать хорошо, пока мы используем БД только для чтения.
По `PostgreSQL` и `Clickhouse` это БД разных типов, последний это OLAP бд, и механизмы обновления данных в них разные. Например, в `Clickhouse` нет транзакций, и все запущенные операции не могут быть отменены, также изменения (`UPDATE`) вносятся постепенно в фоновом режиме (это у них называется мутациями), поэтому данные могу быть изменены не сразу.

По указанным причинам, как только нам понадобятся операции изменения и удаления, нам нужно сопровождать код, связанный с этими 2 БД отдельно.

### Пример 2

Если имеем сервис для составления аналитических очетов для клиентов по данным из БД,
то есть соблазн попробовать абстрагировать это в какую-то отдельную сущность `ClientReport`. Фактически, реализация изначально будет состоять всего лишь из вызова методов (вроде, `get_client_query_params`, `execute_report_query`, `send_query_data_to_client`). Однако спецификация этих очетов всегда зависит от пожелания клиентов (в моем случае мы не может навязывать им како-либо единообразный формат), поэтому всегда есть риск появления очень индивидуальных дополнительных задач, уникальных для каждого отдельного клиента (вроде, создания перед отправкой отчета новой партиции данных в клиентской БД и т.д.). Поэтому такие клиентские задачи нужно поддерживать отдельно.

### Пример 3

Если мы имеем на некотором аналитическом дашборде фильтры для значений (например, список городов, магазинов для фильтрации, временной период и т.д.), то реализация таких фильтров будет в целом схожей. Однако, как мне кажется, здесь будет неправильным обобщить их реализацию, так как в зависимости от передаваемых фильтром на бэкэнд значений, эти значения могу быть совершенно разного характера - например, для списка городов должен реализовываться fuzzy-поиск, для значения продаж товара есть смысл установки значения суммы по всем продажам этого товара, для даты - это группировка в недели/месяцы и т.д.

Поэтому скорее всего было бы неправильно создавать универсальную обработку данных из фильтра, так как это скорее всего приведет как раз к эффекту "боксинга", когда нам будет нужно большое количество аргументов и проверок типов для осуществления ее работы.

## Пример скатывания к боксингу

Да, определенно похоже, что я зашел слишком далеко при попытке сделать функцию, которая должна возвращать диапазон между двумя любыми значениями (для которых это имеет смысл)

```python
def get_value_range(start: T, end: T, step: str | int | float) -> list[T]:
    # Если дата
    if all([
        isinstance(start, datetime),
        isinstance(end, datetime),
        isinstance(step, str),
    ]):
        assert hasattr(timedelta, step), "No such step is possible with timedelta"
        ...
```

Явным признаком этого является различного рода проверки типов и наличия аттрибутов у аргументов функции.
Также, довольно очевидно, что она все еще не полная, и существует большое количество объектов, для которых это будет работать некорректно.
Для каждого нового типа объектов понадобиться добавлять проверки типов или новые агрументы функции, пока она совсем не перестанет быть наглядной.

## Минимализируем обращения к разным частям программы

Был период, когда мне было необходимо написать основу для простого бэкэнда с использованием `FastAPI`. У данного фреймворка имелся (сейчас уже давно не обновляется) полуофициальный репозиторий-шаблон заготовка для новых проектов. На самом деле, этот шаблон очень недалеко ушел от `FizzBuzzEnterpriseEdition` :). Все схемы, модели, эндпоинты были распределены по отдельным папкам, в каждой папке было как минимум 2 уровня вложенности, при работе над любым эндпоинтом предполагалось перемещаться на 2 директории выше от одного места, затем на 2+ директории ниже до нужного места, что без language серевера было практически невозможно.

Как мне кажется это характерно для многих новичков, и меня когда-то тоже -- есть желание поместить каждый функциональный элемент в отдельный модуль.

Сейчас в моей работе это происходит уже не так часто, все-таки всегда должна быть веская причина для создания для создания нового модуля (и уж тем более новой директории с вложенными модулями), сами модули нужно делать как можно менее связанными друг с другом, чтобы они были несцепленными, взаимозаменяемыми и их было легко использовать повторно.

## Выводы

Очевидно, что из-за большой популярности парадигмы ООП, понятие абстракции очень широко распространено в мире IT. Также часто, как это случаеся со многими популярными и полезными вещами, в отдельных случаях это превращается в своего рода карго-культ, когда дедубликация кода проводится только ради ее дедубликации, на совершенно логически несвязанных участках программы, потому что "нам нужно абстрагировать логику программы".
Данное занятие помогло мне намного лучше понять, как отделены все эти механизмы группировки логики работы программы от настоящей абстракции, а также как злоупотребление всеми этими остальными типами абстракции приводит к получению далеко неидеального кода. Стремление всегда придеживаться каких-то правил относительно дедубликации кода приводит зачастую к усложенению понимания программы в целом, особенно в дальнейшем при добавлении нового функционала. Наверное, именно по этой причине и написаны все эти статьи про `wrong abstraction is worse than code duplication`. Впредь не буду пытаться достить полиморфизма ради полиморфизма, но стараться выделять общее только у логически связанных частей программы.