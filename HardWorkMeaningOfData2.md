# Замена передачи по ссылке на иммутабельную копию

## Пример 1

Пример из реализации RAM машины.
При нажатии кнопки `New` должен происходить сброс всей программы и входных/выходных значений.
Один из подходов к этому - перейти из объекта `RAM-машины` по ссылке на программу и изменить её атрибуты, сбросив их до некоторого начального значения.
Аналогично нужно поступить и со значениями пользовательского интерфейса `UI`.

- Было

```python
class RamMachine(QWidget):

 def new(self) -> None:
   self.ui.col_commands.clear()
   self.ui.col_itape.clear()
   self.program.current_command = 0
   self.program.input_tape.current_cell = 0
   self.set_or_update_program()
   self.program.output_tape.clear()
   self.update_ui()
```

Такой подход может быть чреват ошибками. Например, можно "забыть" сбросить какое-то из значений, или порядок очистки также может привести к неожиданным и трудно отлавливаем ошибкам (когда функция сброса изменяет одно и тоже значение).
Способ избежать такого поведения - создание при нажатии `New` новых объектов программы и интерфейса.

- Изменения

```python
class RamMachine(QWidget):

 def new(self) -> None:
   self.program = Program(
       command_cls=Commands,
       reg=Register({}),
       input_tape=InputTape([]),
       output_tape=OutputTape(),
       command_str_list=[],
       current_command=0,
   )
       self.ui = Ui_Form()
       self.ui.setupUi(self)
```

### Выводы 1

- Использованных подход позволяет упростить логику перезапуска программы `RAM-машины` и не беспокоиться о появлении неожиданных ошибок. Нужно отметить, что так получается только один частный случай иммутабельности, поскольку при исполнении остальных команд значения программы изменяются по ссылке (например непосредственно в ходе работы `Run`). В тех случаях изменяемость объекта вроде бы имеет больше смысла.

## Пример 2

Имеется проект, в котором используется код на `Python` для создания подключения к базе данных и выгрузке оттуда аналитических отчетов.
В общем случае, при запуске программы, создавалось подключение к БД.
Затем последовательно запускались отчеты, один за одним. Все эти отчеты использовали одно открытое подключение.
Проблемами могло быть то, что некоторые отчеты формировались достаточно долго, чтобы подключение могло быть автоматически закрыто со стороны БД (также был возможен просто сбой подключения).

- Было

```python
# Пример одного из запросов, где используется по ссылки существующая сессия БД
@log.timing_decorator("CREATE: en category tmp table")
    def create_category_table(self) -> None:
      self.process_config.session.execute(self.create_category_query)
```

Создание под каждый отчет отдельного подключения позволило избежать проблем с подключениями и перейти затем к асинхронным запросам к БД.

- Изменения

```python
@log.timing_decorator("CREATE: en category tmp table")
    async def create_category_table(self) -> None:
    # Создаем вместо этого каждый раз новую сессию
    async with make_session(
         self.process_config.engine, is_async=True
     ) as asession:
        await asession.execute(self.create_category_query)
```

### Выводы 2

- Внесенные в модель изменения позволили не только избавиться от ошибки закрытия подключения БД по таймауту, но также облегчили переход к асинхронным запросам к БД по формированию отчетов. Насколько я знаю, программы для взаимодействия с БД, вроде `SQLAlchemy` используют некоторый пул объектов для подключения (который на самом деле можно настраивать). Но поскольку количество отчетов невелико, у меня не было беспокойства по поводу того, что асинхронный код создаст столько подключений, что они просто закончатся.

## Пример 3

Имеется проект, в котором реализована система алертов для данных в БД, которая анализирует поступающую информацию и при необходимости отправляет сообщение клиентам о наличии проблем.

- Было

```python
def main() -> None:
  # Создаем клиента для получения сообщений о результатах мониторинга
  slack_message_client = SlackWebhookClient(web_hook=SLACK_WEBHOOK)
  # Каждый из мониторингов получает инстанс клиента
  # в данном случае получается, что клиент у всех будет общий
  last_upd_monitoring = LastRawUpdMonitoring(postgresql_db, slack_message_client)
  coutry_monitoring = CountryMonitoring(clickhouse_db, slack_message_client)
```

Проблема в том, что в примере вверху создается только один объект Клиента (т.е. получателя сообщений). Далее получилось так, что клиенту нужно было иметь дополнительное внутреннее состояние, такое как было ли сообщение успешно отправлено.
Можно решать эту проблему введением дополнительного атрибута (`is_sended`), который был отслеживал успешно отправленные сообщения.
Однако в этом случае получается, что класс `Client` должен знать о классах `Monitoring`, а это по идее уже неправильно.

```python
class SlackWebhookClient(Client):
    def __init__(self, **kwargs) -> None:
       super().__init__(**kwargs)
       self.web_hook = kwargs['web_hook']
       is_sended: Dict[Monitoring, self] = {}
```

- Изменения
Для упрощения всей системы, достаточно создавать отдельный объект Клиента под каждый Мониторинг. Для этого можно передавать в мониторинг только ссылку на класс, а объект Клиента будет создаваться внутри конструктора.

```python
class Monitoring(ABC):
    query = "SELECT 1;"
    def __init__(self, db_client: DB, message_client: Type[Client]) -> None:
        self.db_client = db_client
        self.message_client = message_client()
```

### Выводы 3

- Внесенные изменения позволили облегчить логику работы класса Клиента, за счет чего могли быть предотвращены возможные ошибки в результате того, что разные Мониторинги могли влиять на внутреннее состояние одного Клиента.

## Общие выводы

Подход, в котором создается новый объект, вместо изменения внутреннего состояния позволяет предупредить многие ошибки, которые могли бы возникнуть при изменении этого объекта всеми, кто обладает ссылкой на него.
В целом, совместное использование стоит оставлять только там, где оно абсолютно необходимо, во всех остальных случаях лучше изолировать состояние в отдельных местах, что позволят не удерживать в голове все возможные сценарии того, как несколько источников совместно изменяют состоянии одного объекта.
Впредь, буду стараться по умолчанию реализовывать все связи между объектами в декларативном стиле, только если не будет очевидно, что нужно общее состояние.
